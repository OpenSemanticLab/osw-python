{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"osw","text":"<p>Python toolset for data processing, queries, wikicode generation and page manipulation</p>"},{"location":"#note","title":"Note","text":"<p>This is the main page of your project's Sphinx documentation. It is formatted in Markdown. Add additional pages by creating md-files in <code>docs</code> or rst-files (formatted in reStructuredText) and adding links to them in the <code>Contents</code> section below.</p> <p>Please check Sphinx and MyST for more information about how to document your project and how to configure your preferences.</p>"},{"location":"#contents","title":"Contents","text":"<pre><code>:maxdepth: 2\n\nOverview &lt;readme&gt;\nContributions &amp; Help &lt;contributing&gt;\nLicense &lt;license&gt;\nAuthors &lt;authors&gt;\nChangelog &lt;changelog&gt;\nModule Reference &lt;api/modules&gt;\n</code></pre>"},{"location":"#indices-and-tables","title":"Indices and tables","text":"<ul> <li>{ref}<code>genindex</code></li> <li>{ref}<code>modindex</code></li> <li>{ref}<code>search</code></li> </ul>"},{"location":"auth/","title":"Auth","text":"<p>Authentication</p>"},{"location":"auth/#credentialmanager","title":"CredentialManager","text":"<p>               Bases: <code>OswBaseModel</code></p> <p>Handles credentials</p> Source code in <code>src/osw/auth.py</code> <pre><code>class CredentialManager(OswBaseModel):\n    \"\"\"Handles credentials\"\"\"\n\n    cred_filepath: Optional[\n        Union[Union[str, PossibleFilePath], List[Union[str, PossibleFilePath]]]\n    ]\n    \"\"\"Filepath to yaml file with credentials for osw and connected services\"\"\"\n    cert_filepath: Optional[\n        Union[Union[str, PossibleFilePath], List[Union[str, PossibleFilePath]]]\n    ]\n    \"\"\"Filepath to the certificates for osw and connected services\"\"\"\n\n    _credentials: List[BaseCredential] = PrivateAttr([])\n    \"\"\"in memory credential store\"\"\"\n\n    class BaseCredential(OswBaseModel):\n        \"\"\"Abstract base class for credentials\"\"\"\n\n        iri: str\n        \"\"\"the iri the credential is valid for\"\"\"\n\n    class UserPwdCredential(BaseCredential):\n        \"\"\"a username - password credential\"\"\"\n\n        username: str\n        \"\"\"the user identifier\"\"\"\n        password: str\n        \"\"\"the users password\"\"\"\n\n    class OAuth1Credential(BaseCredential):\n        \"\"\"OAuth1 credentials. See\n        https://requests-oauthlib.readthedocs.io/en/latest/oauth1_workflow.html\"\"\"\n\n        consumer_token: str\n        \"\"\"consumer token\"\"\"\n        consumer_secret: str\n        \"\"\"consumer secret \"\"\"\n        access_token: str\n        \"\"\"access token\"\"\"\n        access_secret: str\n        \"\"\"access secret\"\"\"\n\n    class CredentialFallback(Enum):\n        \"\"\"Modes of handling missing credentials\n\n        Attributes\n        ----------\n        none:\n            throw error\n        ask:\n            use getpass to ask for credentials\n        \"\"\"\n\n        ask = \"ask\"  # use getpass to ask for credentials\n        none = \"none\"  # throw error\n\n    class CredentialConfig(OswBaseModel):\n        \"\"\"Reads credentials from a yaml file\"\"\"\n\n        iri: str\n        \"\"\"internationalized resource identifier / address of the service, may contain\n        protocol, domain, port and path matches by \"contains\" returning the shortest\n        match\"\"\"\n        fallback: Optional[CredentialManager.CredentialFallback] = \"none\"\n        \"\"\"The fallback strategy if no credential was found for the given origin\"\"\"\n\n    def __init__(self, **data):\n        super().__init__(**data)\n        if self.cred_filepath:\n            if not isinstance(self.cred_filepath, list):\n                self.cred_filepath = [self.cred_filepath]\n            self.cred_filepath = [Path(fp) for fp in self.cred_filepath if fp != \"\"]\n        # Make sure to at least warn the user if they pass cred_filepath instead of\n        # cred_filepath\n        attribute_names = self.__dict__.keys()\n        unexpected_kwargs = [key for key in data.keys() if key not in attribute_names]\n        if unexpected_kwargs:\n            warn(f\"Unexpected keyword argument(s): {', '.join(unexpected_kwargs)}\")\n\n    def get_credential(self, config: CredentialConfig) -&gt; BaseCredential:\n        \"\"\"Reads credentials from a yaml file or the in memory store\n\n        Parameters\n        ----------\n        config:\n            see CredentialConfig\n\n        Returns\n        -------\n        credential :\n            Credential, contain attributes 'username' and 'password' and\n            the matching iri.\n        \"\"\"\n\n        _file_credentials: List[CredentialManager.BaseCredential] = []\n        if self.cred_filepath:\n            filepaths = self.cred_filepath\n            if type(filepaths) is not list:\n                filepaths = [filepaths]\n\n            for filepath in filepaths:\n                if not filepath.exists():\n                    continue\n                with open(filepath, \"r\", encoding=\"utf-8\") as stream:\n                    try:\n                        accounts = yaml.safe_load(stream)\n                        if accounts is None:  # Catch empty file\n                            continue\n                        for iri in accounts.keys():\n                            if (\n                                \"username\" in accounts[iri]\n                                and \"password\" in accounts[iri]\n                            ):\n                                cred = CredentialManager.UserPwdCredential(\n                                    username=accounts[iri][\"username\"],\n                                    password=accounts[iri][\"password\"],\n                                    iri=iri,\n                                )\n                                _file_credentials.append(cred)\n                            if (\n                                \"consumer_token\" in accounts[iri]\n                                and \"consumer_secret\" in accounts[iri]\n                                and \"access_token\" in accounts[iri]\n                                and \"access_secret\" in accounts[iri]\n                            ):\n                                cred = CredentialManager.OAuth1Credential(\n                                    consumer_token=accounts[iri][\"consumer_token\"],\n                                    consumer_secret=accounts[iri][\"consumer_secret\"],\n                                    access_token=accounts[iri][\"access_token\"],\n                                    access_secret=accounts[iri][\"access_secret\"],\n                                    iri=iri,\n                                )\n                                _file_credentials.append(cred)\n                    except yaml.YAMLError as exc:\n                        print(exc)\n\n        match_iri = \"\"\n        cred = None\n        creds = _file_credentials + self._credentials\n        for _cred in creds:\n            iri = _cred.iri\n            if config.iri in iri:\n                if match_iri == \"\" or len(match_iri) &gt; len(\n                    iri\n                ):  # use the less specific match\n                    match_iri = iri\n                    cred = _cred\n\n        if cred is None:\n            if config.fallback is CredentialManager.CredentialFallback.ask:\n                if self.cred_filepath:\n                    filepath_str = \"', '\".join([str(fp) for fp in self.cred_filepath])\n                    print(\n                        f\"No credentials for {config.iri} found in path '{filepath_str}'. \"\n                        f\"Please use the prompt to login\"\n                    )\n                username = input(\"Enter username: \")\n                password = getpass.getpass(\"Enter password: \")\n                cred = CredentialManager.UserPwdCredential(\n                    username=username, password=password, iri=config.iri\n                )\n                self.add_credential(cred)\n                if self.cred_filepath:\n                    self.save_credentials_to_file()\n        return cred\n\n    def add_credential(self, cred: BaseCredential):\n        \"\"\"adds a credential to the in memory store\n\n        Parameters\n        ----------\n        cred\n            the credential to add\n        \"\"\"\n        self._credentials.append(cred)\n\n    def iri_in_credentials(self, iri: str) -&gt; bool:\n        \"\"\"checks if a credential for a given iri exists\n\n        Parameters\n        ----------\n        iri\n            the iri to check\n\n        Returns\n        -------\n        bool\n            True if a credential exists for the given iri\n        \"\"\"\n        for cred in self._credentials:\n            if cred.iri == iri:\n                return True\n        return False\n\n    def iri_in_file(self, iri: str) -&gt; bool:\n        \"\"\"checks if a credential for a given iri exists in the file\n\n        Parameters\n        ----------\n        iri\n            the iri to check\n\n        Returns\n        -------\n        bool\n            True if a credential exists for the given iri\n        \"\"\"\n        if self.cred_filepath:\n            for fp in self.cred_filepath:\n                if fp != \"\":\n                    if Path(fp).exists():\n                        with open(fp, \"r\", encoding=\"utf-8\") as stream:\n                            try:\n                                accounts = yaml.safe_load(stream)\n                                if accounts is None:  # Catch empty file\n                                    continue\n                                for iri_ in accounts.keys():\n                                    if iri_ == iri:\n                                        return True\n                            except yaml.YAMLError as exc:\n                                print(exc)\n        return False\n\n    def save_credentials_to_file(\n        self,\n        filepath: Union[str, PossibleFilePath] = None,\n        set_cred_filepath: bool = False,\n    ):\n        \"\"\"Saves the in memory credentials to a file\n\n        Parameters\n        ----------\n        filepath\n            The filepath to save the credentials to. If None, the filepath specified\n            in the CredentialManager is used.  If cred_filepath and filepath are None,\n            the default path is used. If the file does not exist, it is created.\n        set_cred_filepath\n            If True, the cred_filepath is set to the given filepath. If False, the\n            cred_filepath of the CredentialManager is not changed.\n        \"\"\"\n        cred_filepaths = [filepath]\n        \"\"\"The filepath to save the credentials to.\"\"\"\n        if filepath is None:\n            cred_filepaths = self.cred_filepath\n            if self.cred_filepath is None:\n                cred_filepaths = [default_paths.cred_filepath]\n        if set_cred_filepath:\n            # Creates error if file does not exist -&gt; Using custom FilePath\n            self.cred_filepath = cred_filepaths\n        for fp in cred_filepaths:\n            file = Path(fp)\n            if not file.parent.exists():\n                file.parent.mkdir(parents=True)\n            data = {}\n            file_already_exists = file.exists()\n            if file_already_exists:\n                data = yaml.safe_load(file.read_text(encoding=\"utf-8\"))\n                if data is None:  # Catch empty file\n                    data = {}\n            for cred in self._credentials:\n                data[cred.iri] = cred.dict(exclude={\"iri\"})\n            with open(fp, \"w\", encoding=\"utf-8\") as stream:\n                yaml.dump(data, stream)\n            if file_already_exists:\n                print(f\"Credentials file updated at '{fp.resolve()}'.\")\n            else:\n                print(f\"Credentials file created at '{fp.resolve()}'.\")\n\n        # Creating or updating .gitignore file in the working directory\n        cwd = Path.cwd()\n        potential_fp = [\n            cwd / \".gitignore\",\n            cwd.parent / \".gitignore\",\n        ]\n        gitignore_fp = potential_fp[0]\n        # Stops if a .gitignore file is found\n        for fp in potential_fp:\n            if fp.exists():\n                gitignore_fp = fp\n                break\n        # Creates a .gitignore file if none is found\n        if not gitignore_fp.exists():\n            if not gitignore_fp.parent.exists():\n                gitignore_fp.parent.mkdir(parents=True)\n            gitignore_fp.touch()\n        # Reads the .gitignore file\n        with open(gitignore_fp, \"r\") as stream:\n            content = stream.read()\n        comment_set = False\n        osw_dir_added = False\n        # For every file path in the list of credentials file paths\n        for _ii, fp in enumerate(cred_filepaths):\n            if default_paths.osw_files_dir in fp.parents and not osw_dir_added:\n                msg = (\n                    f\"Adding '{default_paths.osw_files_dir}' to gitignore file \"\n                    f\"'{gitignore_fp}'.\"\n                )\n                containing_gitignore = gitignore_fp.parent.absolute()\n\n                if containing_gitignore in default_paths.osw_files_dir.parents:\n                    # If the default_path.osw_files_dir is a subdirectory of the directory\n                    # containing the .gitignore file, add the relative path to the\n                    # .gitignore file\n                    rel = default_paths.osw_files_dir.relative_to(containing_gitignore)\n                    to_add = f\"\\n*/{str(rel.as_posix())}/*\"\n                else:\n                    # Test if the default_path.osw_files_dir is a subdirectory of the\n                    # directory containing the .gitignore file\n                    to_add = (\n                        f\"\\n*/{default_paths.osw_files_dir.absolute().as_posix()}/*\"\n                    )\n                osw_dir_added = True\n            else:\n                msg = f\"Adding '{fp.name}' to gitignore file '{gitignore_fp}'.\"\n                to_add = f\"\\n*/{fp.name}\"\n            if not to_add or to_add in content:\n                continue\n            print(msg)\n            with open(gitignore_fp, \"a\") as stream:\n                # Only add comment if not already set\n                comment = (\n                    \"\\n# Automatically added by osw.auth.CredentialManager.\"\n                    \"save_credentials_to_file:\"\n                )\n                if not comment_set and comment not in content:\n                    stream.write(comment)\n                    comment_set = True\n                stream.write(to_add)\n</code></pre>"},{"location":"auth/#osw.auth.CredentialManager._credentials","title":"<code>_credentials = PrivateAttr([])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>in memory credential store</p>"},{"location":"auth/#osw.auth.CredentialManager.cert_filepath","title":"<code>cert_filepath</code>  <code>instance-attribute</code>","text":"<p>Filepath to the certificates for osw and connected services</p>"},{"location":"auth/#osw.auth.CredentialManager.cred_filepath","title":"<code>cred_filepath</code>  <code>instance-attribute</code>","text":"<p>Filepath to yaml file with credentials for osw and connected services</p>"},{"location":"auth/#osw.auth.CredentialManager.BaseCredential","title":"<code>BaseCredential</code>  <code>dataclass</code>","text":"<p>               Bases: <code>OswBaseModel</code></p> <p>Abstract base class for credentials</p> Source code in <code>src/osw/auth.py</code> <pre><code>class BaseCredential(OswBaseModel):\n    \"\"\"Abstract base class for credentials\"\"\"\n\n    iri: str\n    \"\"\"the iri the credential is valid for\"\"\"\n</code></pre>"},{"location":"auth/#osw.auth.CredentialManager.BaseCredential.iri","title":"<code>iri</code>  <code>instance-attribute</code>","text":"<p>the iri the credential is valid for</p>"},{"location":"auth/#osw.auth.CredentialManager.CredentialConfig","title":"<code>CredentialConfig</code>  <code>dataclass</code>","text":"<p>               Bases: <code>OswBaseModel</code></p> <p>Reads credentials from a yaml file</p> Source code in <code>src/osw/auth.py</code> <pre><code>class CredentialConfig(OswBaseModel):\n    \"\"\"Reads credentials from a yaml file\"\"\"\n\n    iri: str\n    \"\"\"internationalized resource identifier / address of the service, may contain\n    protocol, domain, port and path matches by \"contains\" returning the shortest\n    match\"\"\"\n    fallback: Optional[CredentialManager.CredentialFallback] = \"none\"\n    \"\"\"The fallback strategy if no credential was found for the given origin\"\"\"\n</code></pre>"},{"location":"auth/#osw.auth.CredentialManager.CredentialConfig.fallback","title":"<code>fallback = 'none'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The fallback strategy if no credential was found for the given origin</p>"},{"location":"auth/#osw.auth.CredentialManager.CredentialConfig.iri","title":"<code>iri</code>  <code>instance-attribute</code>","text":"<p>internationalized resource identifier / address of the service, may contain protocol, domain, port and path matches by \"contains\" returning the shortest match</p>"},{"location":"auth/#osw.auth.CredentialManager.CredentialFallback","title":"<code>CredentialFallback</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Modes of handling missing credentials</p> <p>Attributes:</p> Name Type Description <code>none</code> <p>throw error</p> <code>ask</code> <p>use getpass to ask for credentials</p> Source code in <code>src/osw/auth.py</code> <pre><code>class CredentialFallback(Enum):\n    \"\"\"Modes of handling missing credentials\n\n    Attributes\n    ----------\n    none:\n        throw error\n    ask:\n        use getpass to ask for credentials\n    \"\"\"\n\n    ask = \"ask\"  # use getpass to ask for credentials\n    none = \"none\"  # throw error\n</code></pre>"},{"location":"auth/#osw.auth.CredentialManager.OAuth1Credential","title":"<code>OAuth1Credential</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BaseCredential</code></p> <p>OAuth1 credentials. See https://requests-oauthlib.readthedocs.io/en/latest/oauth1_workflow.html</p> Source code in <code>src/osw/auth.py</code> <pre><code>class OAuth1Credential(BaseCredential):\n    \"\"\"OAuth1 credentials. See\n    https://requests-oauthlib.readthedocs.io/en/latest/oauth1_workflow.html\"\"\"\n\n    consumer_token: str\n    \"\"\"consumer token\"\"\"\n    consumer_secret: str\n    \"\"\"consumer secret \"\"\"\n    access_token: str\n    \"\"\"access token\"\"\"\n    access_secret: str\n    \"\"\"access secret\"\"\"\n</code></pre>"},{"location":"auth/#osw.auth.CredentialManager.OAuth1Credential.access_secret","title":"<code>access_secret</code>  <code>instance-attribute</code>","text":"<p>access secret</p>"},{"location":"auth/#osw.auth.CredentialManager.OAuth1Credential.access_token","title":"<code>access_token</code>  <code>instance-attribute</code>","text":"<p>access token</p>"},{"location":"auth/#osw.auth.CredentialManager.OAuth1Credential.consumer_secret","title":"<code>consumer_secret</code>  <code>instance-attribute</code>","text":"<p>consumer secret</p>"},{"location":"auth/#osw.auth.CredentialManager.OAuth1Credential.consumer_token","title":"<code>consumer_token</code>  <code>instance-attribute</code>","text":"<p>consumer token</p>"},{"location":"auth/#osw.auth.CredentialManager.UserPwdCredential","title":"<code>UserPwdCredential</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BaseCredential</code></p> <p>a username - password credential</p> Source code in <code>src/osw/auth.py</code> <pre><code>class UserPwdCredential(BaseCredential):\n    \"\"\"a username - password credential\"\"\"\n\n    username: str\n    \"\"\"the user identifier\"\"\"\n    password: str\n    \"\"\"the users password\"\"\"\n</code></pre>"},{"location":"auth/#osw.auth.CredentialManager.UserPwdCredential.password","title":"<code>password</code>  <code>instance-attribute</code>","text":"<p>the users password</p>"},{"location":"auth/#osw.auth.CredentialManager.UserPwdCredential.username","title":"<code>username</code>  <code>instance-attribute</code>","text":"<p>the user identifier</p>"},{"location":"auth/#osw.auth.CredentialManager.add_credential","title":"<code>add_credential(cred)</code>","text":"<p>adds a credential to the in memory store</p> <p>Parameters:</p> Name Type Description Default <code>cred</code> <code>BaseCredential</code> <p>the credential to add</p> required Source code in <code>src/osw/auth.py</code> <pre><code>def add_credential(self, cred: BaseCredential):\n    \"\"\"adds a credential to the in memory store\n\n    Parameters\n    ----------\n    cred\n        the credential to add\n    \"\"\"\n    self._credentials.append(cred)\n</code></pre>"},{"location":"auth/#osw.auth.CredentialManager.get_credential","title":"<code>get_credential(config)</code>","text":"<p>Reads credentials from a yaml file or the in memory store</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>CredentialConfig</code> <p>see CredentialConfig</p> required <p>Returns:</p> Name Type Description <code>credential</code> <code>BaseCredential</code> <p>Credential, contain attributes 'username' and 'password' and the matching iri.</p> Source code in <code>src/osw/auth.py</code> <pre><code>def get_credential(self, config: CredentialConfig) -&gt; BaseCredential:\n    \"\"\"Reads credentials from a yaml file or the in memory store\n\n    Parameters\n    ----------\n    config:\n        see CredentialConfig\n\n    Returns\n    -------\n    credential :\n        Credential, contain attributes 'username' and 'password' and\n        the matching iri.\n    \"\"\"\n\n    _file_credentials: List[CredentialManager.BaseCredential] = []\n    if self.cred_filepath:\n        filepaths = self.cred_filepath\n        if type(filepaths) is not list:\n            filepaths = [filepaths]\n\n        for filepath in filepaths:\n            if not filepath.exists():\n                continue\n            with open(filepath, \"r\", encoding=\"utf-8\") as stream:\n                try:\n                    accounts = yaml.safe_load(stream)\n                    if accounts is None:  # Catch empty file\n                        continue\n                    for iri in accounts.keys():\n                        if (\n                            \"username\" in accounts[iri]\n                            and \"password\" in accounts[iri]\n                        ):\n                            cred = CredentialManager.UserPwdCredential(\n                                username=accounts[iri][\"username\"],\n                                password=accounts[iri][\"password\"],\n                                iri=iri,\n                            )\n                            _file_credentials.append(cred)\n                        if (\n                            \"consumer_token\" in accounts[iri]\n                            and \"consumer_secret\" in accounts[iri]\n                            and \"access_token\" in accounts[iri]\n                            and \"access_secret\" in accounts[iri]\n                        ):\n                            cred = CredentialManager.OAuth1Credential(\n                                consumer_token=accounts[iri][\"consumer_token\"],\n                                consumer_secret=accounts[iri][\"consumer_secret\"],\n                                access_token=accounts[iri][\"access_token\"],\n                                access_secret=accounts[iri][\"access_secret\"],\n                                iri=iri,\n                            )\n                            _file_credentials.append(cred)\n                except yaml.YAMLError as exc:\n                    print(exc)\n\n    match_iri = \"\"\n    cred = None\n    creds = _file_credentials + self._credentials\n    for _cred in creds:\n        iri = _cred.iri\n        if config.iri in iri:\n            if match_iri == \"\" or len(match_iri) &gt; len(\n                iri\n            ):  # use the less specific match\n                match_iri = iri\n                cred = _cred\n\n    if cred is None:\n        if config.fallback is CredentialManager.CredentialFallback.ask:\n            if self.cred_filepath:\n                filepath_str = \"', '\".join([str(fp) for fp in self.cred_filepath])\n                print(\n                    f\"No credentials for {config.iri} found in path '{filepath_str}'. \"\n                    f\"Please use the prompt to login\"\n                )\n            username = input(\"Enter username: \")\n            password = getpass.getpass(\"Enter password: \")\n            cred = CredentialManager.UserPwdCredential(\n                username=username, password=password, iri=config.iri\n            )\n            self.add_credential(cred)\n            if self.cred_filepath:\n                self.save_credentials_to_file()\n    return cred\n</code></pre>"},{"location":"auth/#osw.auth.CredentialManager.iri_in_credentials","title":"<code>iri_in_credentials(iri)</code>","text":"<p>checks if a credential for a given iri exists</p> <p>Parameters:</p> Name Type Description Default <code>iri</code> <code>str</code> <p>the iri to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if a credential exists for the given iri</p> Source code in <code>src/osw/auth.py</code> <pre><code>def iri_in_credentials(self, iri: str) -&gt; bool:\n    \"\"\"checks if a credential for a given iri exists\n\n    Parameters\n    ----------\n    iri\n        the iri to check\n\n    Returns\n    -------\n    bool\n        True if a credential exists for the given iri\n    \"\"\"\n    for cred in self._credentials:\n        if cred.iri == iri:\n            return True\n    return False\n</code></pre>"},{"location":"auth/#osw.auth.CredentialManager.iri_in_file","title":"<code>iri_in_file(iri)</code>","text":"<p>checks if a credential for a given iri exists in the file</p> <p>Parameters:</p> Name Type Description Default <code>iri</code> <code>str</code> <p>the iri to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if a credential exists for the given iri</p> Source code in <code>src/osw/auth.py</code> <pre><code>def iri_in_file(self, iri: str) -&gt; bool:\n    \"\"\"checks if a credential for a given iri exists in the file\n\n    Parameters\n    ----------\n    iri\n        the iri to check\n\n    Returns\n    -------\n    bool\n        True if a credential exists for the given iri\n    \"\"\"\n    if self.cred_filepath:\n        for fp in self.cred_filepath:\n            if fp != \"\":\n                if Path(fp).exists():\n                    with open(fp, \"r\", encoding=\"utf-8\") as stream:\n                        try:\n                            accounts = yaml.safe_load(stream)\n                            if accounts is None:  # Catch empty file\n                                continue\n                            for iri_ in accounts.keys():\n                                if iri_ == iri:\n                                    return True\n                        except yaml.YAMLError as exc:\n                            print(exc)\n    return False\n</code></pre>"},{"location":"auth/#osw.auth.CredentialManager.save_credentials_to_file","title":"<code>save_credentials_to_file(filepath=None, set_cred_filepath=False)</code>","text":"<p>Saves the in memory credentials to a file</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>Union[str, PossibleFilePath]</code> <p>The filepath to save the credentials to. If None, the filepath specified in the CredentialManager is used.  If cred_filepath and filepath are None, the default path is used. If the file does not exist, it is created.</p> <code>None</code> <code>set_cred_filepath</code> <code>bool</code> <p>If True, the cred_filepath is set to the given filepath. If False, the cred_filepath of the CredentialManager is not changed.</p> <code>False</code> Source code in <code>src/osw/auth.py</code> <pre><code>def save_credentials_to_file(\n    self,\n    filepath: Union[str, PossibleFilePath] = None,\n    set_cred_filepath: bool = False,\n):\n    \"\"\"Saves the in memory credentials to a file\n\n    Parameters\n    ----------\n    filepath\n        The filepath to save the credentials to. If None, the filepath specified\n        in the CredentialManager is used.  If cred_filepath and filepath are None,\n        the default path is used. If the file does not exist, it is created.\n    set_cred_filepath\n        If True, the cred_filepath is set to the given filepath. If False, the\n        cred_filepath of the CredentialManager is not changed.\n    \"\"\"\n    cred_filepaths = [filepath]\n    \"\"\"The filepath to save the credentials to.\"\"\"\n    if filepath is None:\n        cred_filepaths = self.cred_filepath\n        if self.cred_filepath is None:\n            cred_filepaths = [default_paths.cred_filepath]\n    if set_cred_filepath:\n        # Creates error if file does not exist -&gt; Using custom FilePath\n        self.cred_filepath = cred_filepaths\n    for fp in cred_filepaths:\n        file = Path(fp)\n        if not file.parent.exists():\n            file.parent.mkdir(parents=True)\n        data = {}\n        file_already_exists = file.exists()\n        if file_already_exists:\n            data = yaml.safe_load(file.read_text(encoding=\"utf-8\"))\n            if data is None:  # Catch empty file\n                data = {}\n        for cred in self._credentials:\n            data[cred.iri] = cred.dict(exclude={\"iri\"})\n        with open(fp, \"w\", encoding=\"utf-8\") as stream:\n            yaml.dump(data, stream)\n        if file_already_exists:\n            print(f\"Credentials file updated at '{fp.resolve()}'.\")\n        else:\n            print(f\"Credentials file created at '{fp.resolve()}'.\")\n\n    # Creating or updating .gitignore file in the working directory\n    cwd = Path.cwd()\n    potential_fp = [\n        cwd / \".gitignore\",\n        cwd.parent / \".gitignore\",\n    ]\n    gitignore_fp = potential_fp[0]\n    # Stops if a .gitignore file is found\n    for fp in potential_fp:\n        if fp.exists():\n            gitignore_fp = fp\n            break\n    # Creates a .gitignore file if none is found\n    if not gitignore_fp.exists():\n        if not gitignore_fp.parent.exists():\n            gitignore_fp.parent.mkdir(parents=True)\n        gitignore_fp.touch()\n    # Reads the .gitignore file\n    with open(gitignore_fp, \"r\") as stream:\n        content = stream.read()\n    comment_set = False\n    osw_dir_added = False\n    # For every file path in the list of credentials file paths\n    for _ii, fp in enumerate(cred_filepaths):\n        if default_paths.osw_files_dir in fp.parents and not osw_dir_added:\n            msg = (\n                f\"Adding '{default_paths.osw_files_dir}' to gitignore file \"\n                f\"'{gitignore_fp}'.\"\n            )\n            containing_gitignore = gitignore_fp.parent.absolute()\n\n            if containing_gitignore in default_paths.osw_files_dir.parents:\n                # If the default_path.osw_files_dir is a subdirectory of the directory\n                # containing the .gitignore file, add the relative path to the\n                # .gitignore file\n                rel = default_paths.osw_files_dir.relative_to(containing_gitignore)\n                to_add = f\"\\n*/{str(rel.as_posix())}/*\"\n            else:\n                # Test if the default_path.osw_files_dir is a subdirectory of the\n                # directory containing the .gitignore file\n                to_add = (\n                    f\"\\n*/{default_paths.osw_files_dir.absolute().as_posix()}/*\"\n                )\n            osw_dir_added = True\n        else:\n            msg = f\"Adding '{fp.name}' to gitignore file '{gitignore_fp}'.\"\n            to_add = f\"\\n*/{fp.name}\"\n        if not to_add or to_add in content:\n            continue\n        print(msg)\n        with open(gitignore_fp, \"a\") as stream:\n            # Only add comment if not already set\n            comment = (\n                \"\\n# Automatically added by osw.auth.CredentialManager.\"\n                \"save_credentials_to_file:\"\n            )\n            if not comment_set and comment not in content:\n                stream.write(comment)\n                comment_set = True\n            stream.write(to_add)\n</code></pre>"},{"location":"authors/","title":"Authors","text":"<p><code>{include} ../AUTHORS.md :relative-docs: docs/ :relative-images:</code></p>"},{"location":"changelog/","title":"Changelog","text":"<p><code>{include} ../CHANGELOG.md :relative-docs: docs/ :relative-images:</code></p>"},{"location":"contributing/","title":"Contributing","text":"<p><code>{include} ../CONTRIBUTING.md :relative-docs: docs/ :relative-images:</code></p>"},{"location":"controller/","title":"OpenSematicLab Controller","text":"<p>A controller extents a model class with functions</p>"},{"location":"controller/#entity","title":"Entity","text":"<p>               Bases: <code>Entity</code></p> Source code in <code>src/osw/controller/entity.py</code> <pre><code>class Entity(model.Entity):\n    def explain(self):\n        print(f\"Entity with label '{str(self.label[0].text)}'\")\n</code></pre>"},{"location":"controller/#databasecontroller","title":"DatabaseController","text":"<p>               Bases: <code>Database</code></p> <p>Provides a sqlalchemy engine for the specified database</p> Source code in <code>src/osw/controller/database.py</code> <pre><code>class DatabaseController(model.Database):\n    \"\"\"\n    Provides a sqlalchemy engine for the specified database\n    \"\"\"\n\n    osw: Optional[OSW]\n    \"\"\" an OSW instance to fetch related resources (host, server, etc.)\"\"\"\n    cm: Optional[Union[CredentialManager.BaseCredential, CredentialManager]]\n    \"\"\" CredentialManager to login to the database\"\"\"\n    engine: Optional[Engine]\n    \"\"\" the internal sqlalchemy engine \"\"\"\n\n    class Config:\n        arbitrary_types_allowed = True\n\n    class ConnectionString(OswBaseModel):\n        \"\"\"the sqlalchemy database connection string\"\"\"\n\n        dialect: str\n        \"\"\" sql subtype, e. g. postgres\"\"\"\n        username: str\n        \"\"\" username for the login \"\"\"\n        password: str\n        \"\"\" password for the login \"\"\"\n        host: str\n        \"\"\" the database host (ip address or domain) \"\"\"\n        port: int\n        \"\"\" the database port \"\"\"\n        database: str\n        \"\"\" the database name / identifier \"\"\"\n        driver: Optional[str]\n        \"\"\" specific driver, e. g. psycopg2 \"\"\"\n\n        def __str__(self):\n            \"\"\"generates the string representation\n\n            Returns\n            -------\n                database connection string\n            \"\"\"\n            prefix = f\"{self.dialect}\"\n            if self.driver:\n                prefix += f\"+{self.driver}\"\n            url = URL.create(\n                prefix,\n                username=self.username,\n                password=self.password,\n                host=self.host,\n                port=self.port,\n                database=self.database,\n            )\n            return url.render_as_string(hide_password=False)\n\n    class ConnectionConfig(OswBaseModel):\n        \"\"\"Database connection configuration\"\"\"\n\n        osw: OSW\n        \"\"\" OSW instance to fetch related resources (host, server, etc.) \"\"\"\n        cm: Union[CredentialManager.BaseCredential, CredentialManager]\n        \"\"\" CredentialManager or direct Credential to login to the database\"\"\"\n\n    def connect(self, config: ConnectionConfig):\n        \"\"\"Initializes the connection to the database by creating a sqlalchemy engine\n\n        Parameters\n        ----------\n        config\n            see ConnectionConfig\n        \"\"\"\n        self.osw = config.osw\n        self.cm = config.cm\n\n        server_title = self.osw.site.semantic_search(\n            f\"[[-HasDbServer::Item:{self.osw.get_osw_id(self.uuid)}]]\"\n        )\n        server = self.osw.load_entity(server_title[0]).cast(model.DatabaseServer)\n\n        host_title = self.osw.site.semantic_search(\n            f\"[[-HasHost::Item:{self.osw.get_osw_id(server.uuid)}]]\"\n        )\n        host = self.osw.load_entity(host_title[0]).cast(model.Host)\n\n        dbtype_title = self.osw.site.semantic_search(\n            f\"[[-HasDbType::Item:{self.osw.get_osw_id(server.uuid)}]]\"\n        )\n        dbtype = self.osw.load_entity(dbtype_title[0]).cast(model.DatabaseType)\n\n        if isinstance(self.cm, CredentialManager.BaseCredential):\n            db_server_cred = self.cm\n        else:\n            db_server_cred = config.cm.get_credential(\n                CredentialManager.CredentialConfig(\n                    iri=f\"{host.network_domain[0]}:{server.network_port[0]}\",\n                    fallback=CredentialManager.CredentialFallback.ask,\n                )\n            )\n\n        cstr = DatabaseController.ConnectionString(\n            dialect=dbtype.connection_str_dialect,\n            driver=dbtype.connection_str_driver,\n            username=db_server_cred.username,\n            password=db_server_cred.password,\n            host=host.network_domain[0],\n            port=server.network_port[0],\n            database=self.name,\n        )\n\n        self.engine = create_engine(str(cstr))\n\n    def execute(self, sql: str):\n        \"\"\"Executes a plain sql string\n\n        Parameters\n        ----------\n        sql\n            the sql string\n        \"\"\"\n        with self.engine.connect() as conn:\n            result_set = conn.execute(sql_text(sql))\n            for r in result_set:\n                print(r)\n</code></pre>"},{"location":"controller/#osw.controller.DatabaseController.cm","title":"<code>cm</code>  <code>instance-attribute</code>","text":"<p>CredentialManager to login to the database</p>"},{"location":"controller/#osw.controller.DatabaseController.engine","title":"<code>engine</code>  <code>instance-attribute</code>","text":"<p>the internal sqlalchemy engine</p>"},{"location":"controller/#osw.controller.DatabaseController.osw","title":"<code>osw</code>  <code>instance-attribute</code>","text":"<p>an OSW instance to fetch related resources (host, server, etc.)</p>"},{"location":"controller/#osw.controller.DatabaseController.ConnectionConfig","title":"<code>ConnectionConfig</code>  <code>dataclass</code>","text":"<p>               Bases: <code>OswBaseModel</code></p> <p>Database connection configuration</p> Source code in <code>src/osw/controller/database.py</code> <pre><code>class ConnectionConfig(OswBaseModel):\n    \"\"\"Database connection configuration\"\"\"\n\n    osw: OSW\n    \"\"\" OSW instance to fetch related resources (host, server, etc.) \"\"\"\n    cm: Union[CredentialManager.BaseCredential, CredentialManager]\n    \"\"\" CredentialManager or direct Credential to login to the database\"\"\"\n</code></pre>"},{"location":"controller/#osw.controller.DatabaseController.ConnectionConfig.cm","title":"<code>cm</code>  <code>instance-attribute</code>","text":"<p>CredentialManager or direct Credential to login to the database</p>"},{"location":"controller/#osw.controller.DatabaseController.ConnectionConfig.osw","title":"<code>osw</code>  <code>instance-attribute</code>","text":"<p>OSW instance to fetch related resources (host, server, etc.)</p>"},{"location":"controller/#osw.controller.DatabaseController.ConnectionString","title":"<code>ConnectionString</code>  <code>dataclass</code>","text":"<p>               Bases: <code>OswBaseModel</code></p> <p>the sqlalchemy database connection string</p> Source code in <code>src/osw/controller/database.py</code> <pre><code>class ConnectionString(OswBaseModel):\n    \"\"\"the sqlalchemy database connection string\"\"\"\n\n    dialect: str\n    \"\"\" sql subtype, e. g. postgres\"\"\"\n    username: str\n    \"\"\" username for the login \"\"\"\n    password: str\n    \"\"\" password for the login \"\"\"\n    host: str\n    \"\"\" the database host (ip address or domain) \"\"\"\n    port: int\n    \"\"\" the database port \"\"\"\n    database: str\n    \"\"\" the database name / identifier \"\"\"\n    driver: Optional[str]\n    \"\"\" specific driver, e. g. psycopg2 \"\"\"\n\n    def __str__(self):\n        \"\"\"generates the string representation\n\n        Returns\n        -------\n            database connection string\n        \"\"\"\n        prefix = f\"{self.dialect}\"\n        if self.driver:\n            prefix += f\"+{self.driver}\"\n        url = URL.create(\n            prefix,\n            username=self.username,\n            password=self.password,\n            host=self.host,\n            port=self.port,\n            database=self.database,\n        )\n        return url.render_as_string(hide_password=False)\n</code></pre>"},{"location":"controller/#osw.controller.DatabaseController.ConnectionString.database","title":"<code>database</code>  <code>instance-attribute</code>","text":"<p>the database name / identifier</p>"},{"location":"controller/#osw.controller.DatabaseController.ConnectionString.dialect","title":"<code>dialect</code>  <code>instance-attribute</code>","text":"<p>sql subtype, e. g. postgres</p>"},{"location":"controller/#osw.controller.DatabaseController.ConnectionString.driver","title":"<code>driver</code>  <code>instance-attribute</code>","text":"<p>specific driver, e. g. psycopg2</p>"},{"location":"controller/#osw.controller.DatabaseController.ConnectionString.host","title":"<code>host</code>  <code>instance-attribute</code>","text":"<p>the database host (ip address or domain)</p>"},{"location":"controller/#osw.controller.DatabaseController.ConnectionString.password","title":"<code>password</code>  <code>instance-attribute</code>","text":"<p>password for the login</p>"},{"location":"controller/#osw.controller.DatabaseController.ConnectionString.port","title":"<code>port</code>  <code>instance-attribute</code>","text":"<p>the database port</p>"},{"location":"controller/#osw.controller.DatabaseController.ConnectionString.username","title":"<code>username</code>  <code>instance-attribute</code>","text":"<p>username for the login</p>"},{"location":"controller/#osw.controller.DatabaseController.ConnectionString.__str__","title":"<code>__str__()</code>","text":"<p>generates the string representation</p> <p>Returns:</p> Type Description <code>    database connection string</code> Source code in <code>src/osw/controller/database.py</code> <pre><code>def __str__(self):\n    \"\"\"generates the string representation\n\n    Returns\n    -------\n        database connection string\n    \"\"\"\n    prefix = f\"{self.dialect}\"\n    if self.driver:\n        prefix += f\"+{self.driver}\"\n    url = URL.create(\n        prefix,\n        username=self.username,\n        password=self.password,\n        host=self.host,\n        port=self.port,\n        database=self.database,\n    )\n    return url.render_as_string(hide_password=False)\n</code></pre>"},{"location":"controller/#osw.controller.DatabaseController.connect","title":"<code>connect(config)</code>","text":"<p>Initializes the connection to the database by creating a sqlalchemy engine</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>ConnectionConfig</code> <p>see ConnectionConfig</p> required Source code in <code>src/osw/controller/database.py</code> <pre><code>def connect(self, config: ConnectionConfig):\n    \"\"\"Initializes the connection to the database by creating a sqlalchemy engine\n\n    Parameters\n    ----------\n    config\n        see ConnectionConfig\n    \"\"\"\n    self.osw = config.osw\n    self.cm = config.cm\n\n    server_title = self.osw.site.semantic_search(\n        f\"[[-HasDbServer::Item:{self.osw.get_osw_id(self.uuid)}]]\"\n    )\n    server = self.osw.load_entity(server_title[0]).cast(model.DatabaseServer)\n\n    host_title = self.osw.site.semantic_search(\n        f\"[[-HasHost::Item:{self.osw.get_osw_id(server.uuid)}]]\"\n    )\n    host = self.osw.load_entity(host_title[0]).cast(model.Host)\n\n    dbtype_title = self.osw.site.semantic_search(\n        f\"[[-HasDbType::Item:{self.osw.get_osw_id(server.uuid)}]]\"\n    )\n    dbtype = self.osw.load_entity(dbtype_title[0]).cast(model.DatabaseType)\n\n    if isinstance(self.cm, CredentialManager.BaseCredential):\n        db_server_cred = self.cm\n    else:\n        db_server_cred = config.cm.get_credential(\n            CredentialManager.CredentialConfig(\n                iri=f\"{host.network_domain[0]}:{server.network_port[0]}\",\n                fallback=CredentialManager.CredentialFallback.ask,\n            )\n        )\n\n    cstr = DatabaseController.ConnectionString(\n        dialect=dbtype.connection_str_dialect,\n        driver=dbtype.connection_str_driver,\n        username=db_server_cred.username,\n        password=db_server_cred.password,\n        host=host.network_domain[0],\n        port=server.network_port[0],\n        database=self.name,\n    )\n\n    self.engine = create_engine(str(cstr))\n</code></pre>"},{"location":"controller/#osw.controller.DatabaseController.execute","title":"<code>execute(sql)</code>","text":"<p>Executes a plain sql string</p> <p>Parameters:</p> Name Type Description Default <code>sql</code> <code>str</code> <p>the sql string</p> required Source code in <code>src/osw/controller/database.py</code> <pre><code>def execute(self, sql: str):\n    \"\"\"Executes a plain sql string\n\n    Parameters\n    ----------\n    sql\n        the sql string\n    \"\"\"\n    with self.engine.connect() as conn:\n        result_set = conn.execute(sql_text(sql))\n        for r in result_set:\n            print(r)\n</code></pre>"},{"location":"dev/","title":"Setup","text":"<ol> <li>create a virtual environment</li> </ol> <pre><code>python -m venv .venv\n</code></pre> <ol> <li>install requirements + extras</li> </ol> <pre><code>pip install -e .[dev,testing]\n</code></pre>"},{"location":"dev/#testing","title":"Testing","text":"<ol> <li> <p>Create new test (file name test_*.py) under /tests</p> </li> <li> <p>Run pytest in the project root dir</p> </li> </ol> <pre><code>tox -e test\n</code></pre> <ol> <li>To run integration test with credentials, run</li> </ol> <pre><code>tox -e test -- --wiki_domain \"&lt;domain&gt;\" --wiki_username \"&lt;login&gt;\" --wiki_password \"&lt;password&gt;\"\n</code></pre>"},{"location":"license/","title":"License","text":"<p><code>{literalinclude} ../LICENSE.txt :language: text</code></p>"},{"location":"model/","title":"Model","text":"<p>OpenSematicLab Model</p>"},{"location":"model/#entity","title":"Entity","text":"<p>               Bases: <code>OswBaseModel</code></p> Source code in <code>src/osw/model/entity.py</code> <pre><code>class Entity(OswBaseModel):\n    rdf_type: Optional[Set[str]] = Field(None, title=\"Additional RDF type(s)\")\n    \"\"\"\n    Declares additional type(s) for this entity, e.g., to state that this entity has the same meaning as a term in a controlled vocabulary or ontology. This property is synonymous to the schema:additionalType and owl:sameAs. The default syntax is ontology:TermName. The ontology prefix has to be defined in the @context of the Entity, the category or any of the parent categories. The term name has to be a valid identifier in the ontology.\n    \"\"\"\n    uuid: UUID = Field(default_factory=uuid4, title=\"UUID\")\n    iri: Optional[str] = Field(None, title=\"IRI\")\n    \"\"\"\n    The Internationalized Resource Identifier (IRI) of this entity\n    \"\"\"\n    name: Optional[str] = Field(None, title=\"Technical name\")\n    \"\"\"\n    Technical / Machine compatible name\n    \"\"\"\n    label: List[Label] = Field(..., min_items=1, title=\"Label(s)\")\n    \"\"\"\n    At least one label is required.\n    \"\"\"\n    short_name: Optional[List[Label]] = Field(None, title=\"Short name(s)\")\n    \"\"\"\n    Abbreviation, Acronym, etc.\n    \"\"\"\n    query_label: Optional[str] = Field(None, title=\"Query label\")\n    description: Optional[List[Description]] = Field(None, title=\"Description\")\n    image: Optional[str] = Field(None, title=\"Image\")\n    ordering_categories: Optional[List[str]] = Field(None, title=\"Ordering categories\")\n    \"\"\"\n    Ordering categories are used to categorize instances, e.g., according to their use but not their properties. When querying for instances of a here listed ordering category, this instance will be returned. Note: Ordering categories define no properties, while 'regular' categories define properties, which an instance assigns values to.\n    \"\"\"\n    keywords: Optional[List[str]] = Field(None, title=\"Keywords / Tags\")\n    \"\"\"\n    Designated to the user defined categorization of this element\n    \"\"\"\n    based_on: Optional[List[str]] = Field(None, title=\"Based on\")\n    \"\"\"\n    Other entities on which this one is based, e.g. when it is created by copying\n    \"\"\"\n    statements: Optional[\n        List[Union[ObjectStatement, DataStatement, QuantityStatement]]\n    ] = Field(None, title=\"Statements\")\n    attachments: Optional[List[str]] = Field(None, title=\"File attachments\")\n    meta: Optional[Meta] = None\n</code></pre>"},{"location":"model/#osw.model.entity.Entity.based_on","title":"<code>based_on = Field(None, title='Based on')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Other entities on which this one is based, e.g. when it is created by copying</p>"},{"location":"model/#osw.model.entity.Entity.iri","title":"<code>iri = Field(None, title='IRI')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Internationalized Resource Identifier (IRI) of this entity</p>"},{"location":"model/#osw.model.entity.Entity.keywords","title":"<code>keywords = Field(None, title='Keywords / Tags')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Designated to the user defined categorization of this element</p>"},{"location":"model/#osw.model.entity.Entity.label","title":"<code>label = Field(..., min_items=1, title='Label(s)')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>At least one label is required.</p>"},{"location":"model/#osw.model.entity.Entity.name","title":"<code>name = Field(None, title='Technical name')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Technical / Machine compatible name</p>"},{"location":"model/#osw.model.entity.Entity.ordering_categories","title":"<code>ordering_categories = Field(None, title='Ordering categories')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Ordering categories are used to categorize instances, e.g., according to their use but not their properties. When querying for instances of a here listed ordering category, this instance will be returned. Note: Ordering categories define no properties, while 'regular' categories define properties, which an instance assigns values to.</p>"},{"location":"model/#osw.model.entity.Entity.rdf_type","title":"<code>rdf_type = Field(None, title='Additional RDF type(s)')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Declares additional type(s) for this entity, e.g., to state that this entity has the same meaning as a term in a controlled vocabulary or ontology. This property is synonymous to the schema:additionalType and owl:sameAs. The default syntax is ontology:TermName. The ontology prefix has to be defined in the @context of the Entity, the category or any of the parent categories. The term name has to be a valid identifier in the ontology.</p>"},{"location":"model/#osw.model.entity.Entity.short_name","title":"<code>short_name = Field(None, title='Short name(s)')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Abbreviation, Acronym, etc.</p>"},{"location":"osw/","title":"Osw","text":"<p>OpenSematicWorld Class</p>"},{"location":"osw/#osw","title":"OSW","text":"<p>               Bases: <code>BaseModel</code></p> <p>Bundles core functionalities of OpenSemanticWorld (OSW)</p> Source code in <code>src/osw/core.py</code> <pre><code>class OSW(BaseModel):\n    \"\"\"Bundles core functionalities of OpenSemanticWorld (OSW)\"\"\"\n\n    uuid: str = \"2ea5b605-c91f-4e5a-9559-3dff79fdd4a5\"\n    _protected_keywords = (\n        \"_osl_template\",\n        \"_osl_footer\",\n    )  # private properties included in model export\n\n    class Config:\n        arbitrary_types_allowed = True  # necessary to allow e.g. np.array as type\n\n    site: WtSite\n\n    @property\n    def mw_site(self) -&gt; Site:\n        \"\"\"Returns the mwclient Site object of the OSW instance.\"\"\"\n        return self.site.mw_site\n\n    def close_connection(self):\n        \"\"\"Close the connection to the OSL instance.\"\"\"\n        self.mw_site.connection.close()\n\n    @staticmethod\n    def get_osw_id(uuid: Union[str, UUID]) -&gt; str:\n        \"\"\"Generates a OSW-ID based on the given uuid by prefixing \"OSW\" and removing\n        all '-' from the uuid-string\n\n        Parameters\n        ----------\n        uuid\n            uuid object, e.g. UUID(\"2ea5b605-c91f-4e5a-9559-3dff79fdd4a5\")\n\n        Returns\n        -------\n            OSW-ID string, e.g. OSW2ea5b605c91f4e5a95593dff79fdd4a5\n        \"\"\"\n        return \"OSW\" + str(uuid).replace(\"-\", \"\")\n\n    @staticmethod\n    def get_uuid(osw_id: str) -&gt; UUID:\n        \"\"\"Returns the uuid for a given OSW-ID\n\n        Parameters\n        ----------\n        osw_id\n            OSW-ID string, e.g. OSW2ea5b605c91f4e5a95593dff79fdd4a5\n\n        Returns\n        -------\n            uuid object, e.g. UUID(\"2ea5b605-c91f-4e5a-9559-3dff79fdd4a5\")\n        \"\"\"\n        return UUID(osw_id.replace(\"OSW\", \"\"))\n\n    class SortEntitiesResult(OswBaseModel):\n        by_name: Dict[str, List[OswBaseModel]]\n        by_type: Dict[str, List[OswBaseModel]]\n\n    @staticmethod\n    def sort_list_of_entities_by_class(\n        entities: List[OswBaseModel],\n        exclude_typeless: bool = True,\n        raise_error: bool = False,\n    ) -&gt; SortEntitiesResult:\n        \"\"\"Sorts a list of entities by class name and type.\n\n        Parameters\n        ----------\n        entities:\n            List of entities to be sorted\n        exclude_typeless:\n            Exclude entities, which are instances of a class that does not\n            define a field 'type'\n        raise_error:\n            Raise an error if an entity can not be processed because it is an\n            instance of class that does not define a field 'type'\n        \"\"\"\n        by_name = {}\n        by_type = {}\n        for entity in entities:\n            # Get class name\n            name = entity.__class__.__name__\n            # See if the class has a type field\n            if \"type\" not in entity.__class__.__fields__:\n                if raise_error:\n                    raise AttributeError(\n                        f\"Instance '{entity}' of class '{name}' can not be processed \"\n                        f\"as the class does not define a field 'type'.\"\n                    )\n                if exclude_typeless:\n                    warn(\n                        f\"Skipping instance '{entity}' of class '{name}' as the class \"\n                        f\"does not define a field 'type'.\"\n                    )\n                    # Excludes the respective entity from the list which will be\n                    #  processed further:\n                    continue\n                model_type = None\n            else:\n                # Get class type if available\n                model_type = entity.__class__.__fields__[\"type\"].get_default()[0]\n            # Add entity to by_name\n            if name not in by_name:\n                by_name[name] = []\n            by_name[name].append(entity)\n            # Add entity to by_type\n            if model_type not in by_type:\n                by_type[model_type] = []\n            by_type[model_type].append(entity)\n\n        return OSW.SortEntitiesResult(by_name=by_name, by_type=by_type)\n\n    class SchemaRegistration(BaseModel):\n        \"\"\"dataclass param of register_schema()\"\"\"\n\n        class Config:\n            arbitrary_types_allowed = True  # allow any class as type\n\n        model_cls: Type[OswBaseModel]\n        \"\"\"The model class\"\"\"\n        schema_uuid: str  # Optional[str] = model_cls.__uuid__\n        \"\"\"The schema uuid\"\"\"\n        schema_name: str  # Optional[str] = model_cls.__name__\n        \"\"\"The schema name\"\"\"\n        schema_bases: List[str] = Field(default=[\"Category:Item\"])\n        \"\"\"A list of base schemas (referenced by allOf)\"\"\"\n\n    def register_schema(self, schema_registration: SchemaRegistration):\n        \"\"\"Registers a new or updated schema in OSW by creating the corresponding\n        category page.\n\n        Parameters\n        ----------\n        schema_registration\n            see SchemaRegistration\n        \"\"\"\n        entity = schema_registration.model_cls\n\n        jsondata = {}\n        jsondata[\"uuid\"] = schema_registration.schema_uuid\n        jsondata[\"label\"] = {\"text\": schema_registration.schema_name, \"lang\": \"en\"}\n        jsondata[\"subclass_of\"] = schema_registration.schema_bases\n\n        if issubclass(entity, BaseModel):\n            entity_title = \"Category:\" + OSW.get_osw_id(schema_registration.schema_uuid)\n\n            page = WtPage(wtSite=self.site, title=entity_title)\n            if page.exists:\n                page = self.site.get_page(\n                    WtSite.GetPageParam(titles=[entity_title])\n                ).pages[0]\n\n            page.set_slot_content(\"jsondata\", jsondata)\n\n            schema = json.loads(\n                entity.schema_json(indent=4).replace(\"$ref\", \"dollarref\")\n            )\n\n            jsonpath_expr = parse(\"$..allOf\")\n            # Replace local definitions (#/definitions/...) with embedded definitions\n            #  to prevent resolve errors in json-editor\n            for match in jsonpath_expr.find(schema):\n                result_array = []\n                for subschema in match.value:\n                    # pprint(subschema)\n                    value = subschema[\"dollarref\"]\n                    if value.startswith(\"#\"):\n                        definition_jsonpath_expr = parse(\n                            value.replace(\"#\", \"$\").replace(\"/\", \".\")\n                        )\n                        for def_match in definition_jsonpath_expr.find(schema):\n                            # pprint(def_match.value)\n                            result_array.append(def_match.value)\n                    else:\n                        result_array.append(subschema)\n                match.full_path.update_or_create(schema, result_array)\n            if \"definitions\" in schema:\n                del schema[\"definitions\"]\n\n            if \"allOf\" not in schema:\n                schema[\"allOf\"] = []\n            for base in schema_registration.schema_bases:\n                schema[\"allOf\"].append(\n                    {\"$ref\": f\"/wiki/{base}?action=raw&amp;slot=jsonschema\"}\n                )\n\n            page.set_slot_content(\"jsonschema\", schema)\n        else:\n            print(\"Error: Unsupported entity type\")\n            return\n\n        page.edit()\n        print(\"Entity stored at \" + page.get_url())\n\n    class SchemaUnregistration(BaseModel):\n        \"\"\"dataclass param of register_schema()\"\"\"\n\n        class Config:\n            arbitrary_types_allowed = True  # allow any class as type\n\n        model_cls: Optional[Type[OswBaseModel]]\n        \"\"\"The model class\"\"\"\n        model_uuid: Optional[str]\n        \"\"\"The model uuid\"\"\"\n        comment: Optional[str]\n        \"\"\"The comment for the deletion, to be left behind\"\"\"\n\n    def unregister_schema(self, schema_unregistration: SchemaUnregistration):\n        \"\"\"deletes the corresponding category page\n\n        Parameters\n        ----------\n        schema_unregistration\n            see SchemaUnregistration\n        \"\"\"\n        uuid = \"\"\n        if schema_unregistration.model_uuid:\n            uuid = schema_unregistration.model_uuid\n        elif (\n            not uuid\n            and schema_unregistration.model_cls\n            and issubclass(schema_unregistration.model_cls, BaseModel)\n        ):\n            uuid = schema_unregistration.model_cls.__uuid__\n        else:\n            print(\"Error: Neither model nor model id provided\")\n\n        entity_title = \"Category:\" + OSW.get_osw_id(uuid)\n        page = self.site.get_page(WtSite.GetPageParam(titles=[entity_title])).pages[0]\n        page.delete(schema_unregistration.comment)\n\n    class FetchSchemaMode(Enum):\n        \"\"\"Modes of the FetchSchemaParam class\n\n        Attributes\n        ----------\n        append:\n            append to the current model\n        replace:\n            replace the current model\n        \"\"\"\n\n        append = \"append\"  # append to the current model\n        replace = \"replace\"  # replace the current model\n\n    class FetchSchemaParam(BaseModel):\n        \"\"\"Param for fetch_schema()\n\n        Attributes\n        ----------\n        schema_title:\n            one or multiple titles (wiki page name) of schemas (default: Category:Item)\n        mode:\n            append or replace (default) current schema, see FetchSchemaMode\n        \"\"\"\n\n        schema_title: Optional[Union[List[str], str]] = \"Category:Item\"\n        mode: Optional[str] = (\n            \"replace\"\n            # type 'FetchSchemaMode' requires: 'from __future__ import annotations'\n        )\n        legacy_generator: Optional[bool] = False\n        \"\"\"uses legacy command line for code generation if true\"\"\"\n\n    def fetch_schema(self, fetchSchemaParam: FetchSchemaParam = None) -&gt; None:\n        \"\"\"Loads the given schemas from the OSW instance and auto-generates python\n        datasclasses within osw.model.entity from it\n\n        Parameters\n        ----------\n        fetchSchemaParam\n            See FetchSchemaParam, by default None\n        \"\"\"\n        if not isinstance(fetchSchemaParam.schema_title, list):\n            fetchSchemaParam.schema_title = [fetchSchemaParam.schema_title]\n        first = True\n        for schema_title in fetchSchemaParam.schema_title:\n            mode = fetchSchemaParam.mode\n            if not first:  # 'replace' makes only sense for the first schema\n                mode = \"append\"\n            self._fetch_schema(\n                OSW._FetchSchemaParam(\n                    schema_title=schema_title,\n                    mode=mode,\n                    legacy_generator=fetchSchemaParam.legacy_generator,\n                )\n            )\n            first = False\n\n    class _FetchSchemaParam(BaseModel):\n        \"\"\"Internal param for _fetch_schema()\n\n        Attributes\n        ----------\n        schema_title:\n            the title (wiki page name) of the schema (default: Category:Item)\n        root:\n            marks the root iteration for a recursive fetch (internal param,\n            default: True)\n        mode:\n            append or replace (default) current schema, see FetchSchemaMode\n        \"\"\"\n\n        schema_title: Optional[str] = \"Category:Item\"\n        root: Optional[bool] = True\n        mode: Optional[str] = (\n            \"replace\"\n            # type 'FetchSchemaMode' requires: 'from __future__ import annotations'\n        )\n        legacy_generator: Optional[bool] = False\n        \"\"\"uses legacy command line for code generation if true\"\"\"\n\n    def _fetch_schema(self, fetchSchemaParam: _FetchSchemaParam = None) -&gt; None:\n        \"\"\"Loads the given schema from the OSW instance and autogenerates python\n        datasclasses within osw.model.entity from it\n\n        Parameters\n        ----------\n        fetchSchemaParam\n            See FetchSchemaParam, by default None\n        \"\"\"\n        site_cache_state = self.site.get_cache_enabled()\n        self.site.enable_cache()\n        if fetchSchemaParam is None:\n            fetchSchemaParam = OSW._FetchSchemaParam()\n        schema_title = fetchSchemaParam.schema_title\n        root = fetchSchemaParam.root\n        schema_name = schema_title.split(\":\")[-1]\n        page = self.site.get_page(WtSite.GetPageParam(titles=[schema_title])).pages[0]\n        if not page.exists:\n            print(f\"Error: Page {schema_title} does not exist\")\n            return\n        # not only in the JsonSchema namespace the schema is located in the main sot\n        # in all other namespaces, the json_schema slot is used\n        if schema_title.startswith(\"JsonSchema:\"):\n            schema_str = \"\"\n            if page.get_slot_content(\"main\"):\n                schema_str = json.dumps(page.get_slot_content(\"main\"))\n        else:\n            schema_str = \"\"\n            if page.get_slot_content(\"jsonschema\"):\n                schema_str = json.dumps(page.get_slot_content(\"jsonschema\"))\n        if (schema_str is None) or (schema_str == \"\"):\n            print(f\"Error: Schema {schema_title} does not exist\")\n            schema_str = \"{}\"  # empty schema to make reference work\n        schema = json.loads(\n            schema_str.replace(\"$ref\", \"dollarref\").replace(\n                # '$' is a special char for root object in jsonpath\n                '\"allOf\": [',\n                '\"allOf\": [{},',\n            )\n            # fix https://github.com/koxudaxi/datamodel-code-generator/issues/1910\n        )\n        print(f\"Fetch {schema_title}\")\n\n        jsonpath_expr = parse(\"$..dollarref\")\n        for match in jsonpath_expr.find(schema):\n            # value = \"https://\" + self.mw_site.host + match.value\n            if match.value.startswith(\"#\"):\n                continue  # skip self references\n            ref_schema_title = match.value.replace(\"/wiki/\", \"\").split(\"?\")[0]\n            ref_schema_name = ref_schema_title.split(\":\")[-1] + \".json\"\n            value = \"\"\n            for _i in range(0, schema_name.count(\"/\")):\n                value += \"../\"  # created relative path to top-level schema dir\n            value += ref_schema_name  # create a reference to a local file\n            # keep document-relative jsonpointer if present\n            if \"#/\" in match.value:\n                value += \"#/\" + match.value.split(\"#/\")[-1]\n            match.full_path.update_or_create(schema, value)\n            # print(f\"replace {match.value} with {value}\")\n            if (\n                ref_schema_title != schema_title\n            ):  # prevent recursion in case of self references\n                self._fetch_schema(\n                    OSW._FetchSchemaParam(schema_title=ref_schema_title, root=False)\n                )  # resolve references recursive\n\n        model_dir_path = os.path.join(\n            os.path.dirname(os.path.abspath(__file__)), \"model\"\n        )  # src/model\n        schema_path = os.path.join(model_dir_path, schema_name + \".json\")\n        os.makedirs(os.path.dirname(schema_path), exist_ok=True)\n        with open(schema_path, \"w\", encoding=\"utf-8\") as f:\n            schema_str = json.dumps(schema, ensure_ascii=False, indent=4).replace(\n                \"dollarref\", \"$ref\"\n            )\n            # print(schema_str)\n            f.write(schema_str)\n\n        # result_model_path = schema_path.replace(\".json\", \".py\")\n        result_model_path = os.path.join(model_dir_path, \"entity.py\")\n        temp_model_path = os.path.join(model_dir_path, \"temp.py\")\n        if root:\n            if fetchSchemaParam.legacy_generator:\n                exec_name = \"datamodel-codegen\"\n                # default: assume datamodel-codegen is in PATH\n                exec_path = exec_name\n                if platform.system() == \"Windows\":\n                    exec_name += \".exe\"\n                    exec_path = os.path.join(\n                        os.path.dirname(os.path.abspath(sys.executable)), exec_name\n                    )\n                    if not os.path.isfile(exec_path):\n                        exec_path = os.path.join(\n                            os.path.dirname(os.path.abspath(sys.executable)),\n                            \"Scripts\",\n                            exec_name,\n                        )\n                    if not os.path.isfile(exec_path):\n                        print(\"Error: datamodel-codegen not found\")\n                        return\n                os.system(\n                    f\"{exec_path}  \\\n                    --input {schema_path} \\\n                    --input-file-type jsonschema \\\n                    --output {temp_model_path} \\\n                    --base-class osw.model.static.OswBaseModel \\\n                    --use-default \\\n                    --use-unique-items-as-set \\\n                    --enum-field-as-literal all \\\n                    --use-title-as-name \\\n                    --use-schema-description \\\n                    --use-field-description \\\n                    --encoding utf-8 \\\n                    --use-double-quotes \\\n                    --collapse-root-models \\\n                    --reuse-model \\\n                \"\n                )\n            else:\n                datamodel_code_generator.generate(\n                    input_=pathlib.Path(schema_path),\n                    input_file_type=\"jsonschema\",\n                    output=pathlib.Path(temp_model_path),\n                    base_class=\"osw.model.static.OswBaseModel\",\n                    # use_default=True,\n                    apply_default_values_for_required_fields=True,\n                    use_unique_items_as_set=True,\n                    enum_field_as_literal=datamodel_code_generator.LiteralType.All,\n                    use_title_as_name=True,\n                    use_schema_description=True,\n                    use_field_description=True,\n                    encoding=\"utf-8\",\n                    use_double_quotes=True,\n                    collapse_root_models=True,\n                    reuse_model=True,\n                )\n\n            # see https://koxudaxi.github.io/datamodel-code-generator/\n            # --base-class OswBaseModel: use a custom base class\n            # --custom-template-dir src/model/template_data/\n            # --extra-template-data src/model/template_data/extra.json\n            # --use-default: Use default value even if a field is required\n            # --use-unique-items-as-set: define field type as `set` when the field\n            #  attribute has`uniqueItems`\n            # --enum-field-as-literal all: prevent 'value is not a valid enumeration\n            #  member' errors after schema reloading\n            # --use-schema-description: Use schema description to populate class\n            #  docstring\n            # --use-field-description: Use schema description to populate field\n            #  docstring\n            # --use-title-as-name: use titles as class names of models, e.g. for the\n            #  footer templates\n            # --collapse-root-models: Models generated with a root-type field will be\n            #  merged\n            # into the models using that root-type model, e.g. for Entity.statements\n            # --reuse-model: Re-use models on the field when a module has the model\n            #  with the same content\n\n            content = \"\"\n            with open(temp_model_path, \"r\", encoding=\"utf-8\") as f:\n                content = f.read()\n            os.remove(temp_model_path)\n\n            content = re.sub(\n                r\"(UUID = Field\\(...)\",\n                r\"UUID = Field(default_factory=uuid4\",\n                content,\n            )  # enable default value for uuid\n\n            # we are now using pydantic.v1\n            # pydantic imports lead to uninitialized fields (FieldInfo still present)\n            content = re.sub(\n                r\"(from pydantic import)\", \"from pydantic.v1 import\", content\n            )\n\n            # remove field param unique_items\n            # --use-unique-items-as-set still keeps unique_items=True as Field param\n            # which was removed, see https://github.com/pydantic/pydantic-core/issues/296\n            # --output-model-type pydantic_v2.BaseModel fixes that but generated models\n            # are not v1 compatible mainly by using update_model()\n            content = re.sub(r\"(,?\\s*unique_items=True\\s*)\", \"\", content)\n\n            if fetchSchemaParam.mode == \"replace\":\n                header = (\n                    \"from uuid import uuid4\\n\"\n                    \"from typing import Type, TypeVar\\n\"\n                    \"from osw.model.static import OswBaseModel, Ontology\\n\"\n                    # \"from osw.model.static import *\\n\"\n                    \"\\n\"\n                )\n\n                content = re.sub(\n                    pattern=r\"(class\\s*\\S*\\s*\\(\\s*OswBaseModel\\s*\\)\\s*:.*\\n)\",\n                    repl=header + r\"\\n\\n\\n\\1\",\n                    string=content,\n                    count=1,\n                )  # add header before first class declaration\n\n                with open(result_model_path, \"w\", encoding=\"utf-8\") as f:\n                    f.write(content)\n\n            if fetchSchemaParam.mode == \"append\":\n                org_content = \"\"\n                with open(result_model_path, \"r\", encoding=\"utf-8\") as f:\n                    org_content = f.read()\n\n                pattern = re.compile(\n                    r\"class\\s*([\\S]*)\\s*\\(\\s*\\S*\\s*\\)\\s*:.*\\n\"\n                )  # match class definition [\\s\\S]*(?:[^\\S\\n]*\\n){2,}\n                for cls in re.findall(pattern, org_content):\n                    print(cls)\n                    content = re.sub(\n                        r\"(class\\s*\"\n                        + cls\n                        + r\"\\s*\\(\\s*\\S*\\s*\\)\\s*:.*\\n[\\s\\S]*?(?:[^\\S\\n]*\\n){3,})\",\n                        \"\",\n                        content,\n                        count=1,\n                    )  # replace duplicated classes\n\n                content = re.sub(\n                    pattern=r\"(from __future__ import annotations)\",\n                    repl=\"\",\n                    string=content,\n                    count=1,\n                )  # remove import statement\n                # print(content)\n                with open(result_model_path, \"a\", encoding=\"utf-8\") as f:\n                    f.write(content)\n\n            importlib.reload(model)  # reload the updated module\n            if not site_cache_state:\n                self.site.disable_cache()  # restore original state\n\n    def install_dependencies(\n        self,\n        dependencies: Dict[str, str] = None,\n        mode: str = \"append\",\n        policy: str = \"force\",\n    ):\n        \"\"\"Installs data models, listed in the dependencies, in the osw.model.entity\n        module.\n\n        Parameters\n        ----------\n        dependencies\n            A dictionary with the keys being the names of the dependencies and the\n            values being the full page name (IRI) of the dependencies.\n        mode\n            The mode to use when loading the dependencies. Default is 'append',\n            which will keep existing data models and only load the missing ones. The\n            mode 'replace' will replace all existing data models with the new ones.\n        policy\n            The policy to use when loading the dependencies. Default is 'force',\n            which will always load the dependencies. If policy is 'if-missing',\n            dependencies will only be loaded if they are not already installed.\n            This may lead to outdated dependencies, if the dependencies have been\n            updated on the server. If policy is 'if-outdated', dependencies will only\n            be loaded if they were updated on the server. (not implemented yet)\n        \"\"\"\n        if dependencies is None:\n            if default_params.dependencies is None:\n                raise ValueError(\n                    \"No 'dependencies' parameter was passed to \"\n                    \"install_dependencies() and \"\n                    \"osw.defaults.params.dependencies was not set!\"\n                )\n            dependencies = default_params.dependencies\n        schema_fpts = []\n        for k, v in dependencies.items():\n            if policy != \"if-missing\" or not hasattr(model, k):\n                schema_fpts.append(v)\n            if policy == \"if-outdated\":\n                raise NotImplementedError(\n                    \"The policy 'if-outdated' is not implemented yet.\"\n                )\n        schema_fpts = list(set(schema_fpts))\n        for schema_fpt in schema_fpts:\n            if not schema_fpt.count(\":\") == 1:\n                raise ValueError(\n                    f\"Full page title '{schema_fpt}' does not have the correct format. \"\n                    \"It should be 'Namespace:Name'.\"\n                )\n        self.fetch_schema(OSW.FetchSchemaParam(schema_title=schema_fpts, mode=mode))\n\n    @staticmethod\n    def check_dependencies(dependencies: Dict[str, str]) -&gt; List[str]:\n        \"\"\"Check if the dependencies are installed in the osw.model.entity module.\n\n        Parameters\n        ----------\n        dependencies\n            A dictionary with the keys being the names of the dependencies and the\n            values being the full page name (IRI) of the dependencies.\n        \"\"\"\n        return [dep for dep in dependencies if not hasattr(model, dep)]\n\n    def ensure_dependencies(self, dependencies: Dict[str, str]):\n        \"\"\"Ensure that the dependencies are installed in the osw.model.entity module.\n\n        Parameters\n        ----------\n        dependencies\n            A dictionary with the keys being the names of the dependencies and the\n            values being the full page name (IRI) of the dependencies.\n        \"\"\"\n        if self.check_dependencies(dependencies):\n            self.install_dependencies(dependencies)\n\n    class LoadEntityParam(BaseModel):\n        \"\"\"Param for load_entity()\"\"\"\n\n        titles: Union[str, List[str]]\n        \"\"\"The pages titles to load - one or multiple titles (wiki page name) of\n        entities\"\"\"\n        autofetch_schema: Optional[bool] = True\n        \"\"\"If true, load the corresponding schemas /\n        categories ad-hoc if not already present\"\"\"\n        model_to_use: Optional[Type[OswBaseModel]] = None\n        \"\"\"If provided this model will be used to create an entity (instance of the\n        model), instead of instantiating the autofetched schema.\"\"\"\n        remove_empty: Optional[bool] = True\n        \"\"\"If true, remove key with an empty string, list, dict or set as value\n        from the jsondata.\"\"\"\n        disable_cache: bool = False\n        \"\"\"If true, disable the cache for the loading process\"\"\"\n\n        def __init__(self, **data):\n            super().__init__(**data)\n            if not isinstance(self.titles, list):\n                self.titles = [self.titles]\n\n    class LoadEntityResult(BaseModel):\n        \"\"\"Result of load_entity()\"\"\"\n\n        entities: Union[model.Entity, List[model.Entity]]\n        \"\"\"The dataclass instance(s)\"\"\"\n\n    # fmt: off\n    @overload\n    def load_entity(self, entity_title: str) -&gt; model.Entity:\n        ...\n\n    @overload\n    def load_entity(self, entity_title: List[str]) -&gt; List[model.Entity]:\n        ...\n\n    @overload\n    def load_entity(self, entity_title: LoadEntityParam) -&gt; LoadEntityResult:\n        ...\n\n    # fmt: on\n\n    def load_entity(\n        self, entity_title: Union[str, List[str], LoadEntityParam]\n    ) -&gt; Union[model.Entity, List[model.Entity], LoadEntityResult]:\n        \"\"\"Loads the entity with the given wiki page name from the OSW instance.\n        Creates an instance of the class specified by the \"type\" attribute, default\n        model.Entity. An instance of model.Entity can be cast to any subclass with\n        .cast(model.&lt;class&gt;) .\n\n        Parameters\n        ----------\n        entity_title\n            the wiki page name\n\n        Returns\n        -------\n            the dataclass instance if only a single title is given\n            a list of dataclass instances if a list of titles is given\n            a LoadEntityResult instance if a LoadEntityParam is given\n        \"\"\"\n        if isinstance(entity_title, str):\n            param = OSW.LoadEntityParam(titles=[entity_title])\n        elif isinstance(entity_title, list):\n            param = OSW.LoadEntityParam(titles=entity_title)\n        else:\n            param = entity_title\n\n        if param.model_to_use:\n            print(f\"Using schema {param.model_to_use.__name__} to create entity\")\n\n        # store original cache state\n        cache_state = self.site.get_cache_enabled()\n        if param.disable_cache:\n            self.site.disable_cache()\n        if not cache_state and param.disable_cache:\n            # enable cache to speed up loading\n            self.site.enable_cache()\n\n        entities = []\n        pages = self.site.get_page(WtSite.GetPageParam(titles=param.titles)).pages\n        for page in pages:\n            entity = None\n            schemas = []\n            schemas_fetched = True\n            jsondata = page.get_slot_content(\"jsondata\")\n            if param.remove_empty:\n                remove_empty(jsondata)\n            if jsondata:\n                for category in jsondata[\"type\"]:\n                    schema = (\n                        self.site.get_page(WtSite.GetPageParam(titles=[category]))\n                        .pages[0]\n                        .get_slot_content(\"jsonschema\")\n                    )\n                    schemas.append(schema)\n                    # generate model if not already exists\n                    cls_name: str = schema[\"title\"]\n                    # If a schema_to_use is provided, we do not need to check if the\n                    #  model exists\n                    if not param.model_to_use:\n                        if not hasattr(model, cls_name):\n                            if param.autofetch_schema:\n                                self.fetch_schema(\n                                    OSW.FetchSchemaParam(\n                                        schema_title=category, mode=\"append\"\n                                    )\n                                )\n                        if not hasattr(model, cls_name):\n                            schemas_fetched = False\n                            print(\n                                f\"Error: Model {cls_name} not found. Schema {category} \"\n                                f\"needs to be fetched first.\"\n                            )\n            if not schemas_fetched:\n                continue\n\n            if param.model_to_use:\n                entity: model.OswBaseModel = param.model_to_use(**jsondata)\n\n            elif len(schemas) == 0:\n                print(\"Error: no schema defined\")\n\n            elif len(schemas) == 1:\n                cls: Type[model.Entity] = getattr(model, schemas[0][\"title\"])\n                entity: model.Entity = cls(**jsondata)\n\n            else:\n                bases = []\n                for schema in schemas:\n                    bases.append(getattr(model, schema[\"title\"]))\n                cls = create_model(\"Test\", __base__=tuple(bases))\n                entity: model.Entity = cls(**jsondata)\n\n            if entity is not None:\n                # make sure we do not override existing metadata\n                if not hasattr(entity, \"meta\") or entity.meta is None:\n                    entity.meta = model.Meta()\n                if (\n                    not hasattr(entity.meta, \"wiki_page\")\n                    or entity.meta.wiki_page is None\n                ):\n                    entity.meta.wiki_page = model.WikiPage()\n                entity.meta.wiki_page.namespace = namespace_from_full_title(page.title)\n                entity.meta.wiki_page.title = title_from_full_title(page.title)\n\n            entities.append(entity)\n        # restore original cache state\n        if cache_state:\n            self.site.enable_cache()\n        else:\n            self.site.disable_cache()\n\n        if isinstance(entity_title, str):  # single title\n            if len(entities) &gt;= 1:\n                return entities[0]\n            else:\n                return None\n        if isinstance(entity_title, list):  # list of titles\n            return entities\n        if isinstance(entity_title, OSW.LoadEntityParam):  # LoadEntityParam\n            return OSW.LoadEntityResult(entities=entities)\n\n    class OverwriteClassParam(OswBaseModel):\n        model: Type[OswBaseModel]  # ModelMetaclass\n        \"\"\"The model class for which this is the overwrite params object.\"\"\"\n        overwrite: Optional[OVERWRITE_CLASS_OPTIONS] = False\n        \"\"\"Defines the overall overwriting behavior. Used for any property if the\n        property specific setting is not set.\"\"\"\n        per_property: Optional[Dict[str, OverwriteOptions]] = None\n        \"\"\"A key (property name) - value (overwrite setting) pair.\"\"\"\n        _per_property: Dict[str, OVERWRITE_CLASS_OPTIONS] = PrivateAttr()\n        \"\"\"Private property, for internal use only. Use 'per_property' instead\"\"\"\n\n        @validator(\"per_property\")\n        def validate_per_property(cls, per_property, values):\n            model_ = values.get(\"model\")\n            field_names = list(model_.__fields__.keys())\n            keys = per_property.keys()\n            if not all(key in field_names for key in keys):\n                missing_keys = [key for key in keys if key not in field_names]\n                raise ValueError(\n                    f\"Property not found in model: {', '.join(missing_keys)}\"\n                )\n\n            return per_property\n\n        def __setattr__(self, key, value):\n            \"\"\"Called when setting an attribute\"\"\"\n            super().__setattr__(key, value)\n            if key == \"per_property\":\n                # compare value and self.per_property\n                if value != self.per_property and value is not None:\n                    self._per_property = {\n                        field_name: value.get(field_name, self.overwrite)\n                        for field_name in self.model.__fields__.keys()\n                    }\n            elif key == \"overwrite\":\n                if self.per_property is not None:\n                    self._per_property = {\n                        field_name: self.per_property.get(field_name, self.overwrite)\n                        for field_name in self.model.__fields__.keys()\n                    }\n            elif key == \"model\":\n                if self.per_property is not None:\n                    self._per_property = {\n                        field_name: self.per_property.get(field_name, self.overwrite)\n                        for field_name in self.model.__fields__.keys()\n                    }\n\n        def __init__(self, **data):\n            \"\"\"Called after validation. Sets the fallback for every property that\n            has not been specified in per_property.\"\"\"\n            super().__init__(**data)\n            per_property_ = {}\n            if self.per_property is not None:\n                per_property_ = self.per_property\n            self._per_property = {\n                field_name: per_property_.get(field_name, self.overwrite)\n                for field_name in self.model.__fields__.keys()\n            }\n            # todo: from class definition get properties with hidden /\n            #  read_only option  #  those can be safely overwritten - set the to True\n\n        def get_overwrite_setting(self, property_name: str) -&gt; OverwriteOptions:\n            \"\"\"Returns the fallback overwrite option for the given field name\"\"\"\n            return self._per_property.get(property_name, self.overwrite)\n\n    class _ApplyOverwriteParam(OswBaseModel):\n        page: WtPage\n        entity: OswBaseModel  # actually model.Entity but this causes the \"type\" error\n        policy: Union[OSW.OverwriteClassParam, OVERWRITE_CLASS_OPTIONS]\n        namespace: Optional[str]\n        remove_empty: Optional[bool] = True\n        inplace: Optional[bool] = False\n        debug: Optional[bool] = False\n        offline: Optional[bool] = False\n\n        class Config:\n            arbitrary_types_allowed = True\n\n        @validator(\"entity\")\n        def validate_entity(cls, entity, values):\n            \"\"\"Make sure that the passed entity has the same uuid as the page\"\"\"\n            page: WtPage = values.get(\"page\")\n            if not page.exists:  # Guard clause\n                return entity\n            jsondata = page.get_slot_content(\"jsondata\")\n            if jsondata is None:  # Guard clause\n                title = title_from_full_title(page.title)\n                try:\n                    uuid_from_title = get_uuid(title)\n                except ValueError:\n                    print(\n                        f\"Error: UUID could not be determined from title: '{title}', \"\n                        f\"nor fromjsondata: {jsondata}\"\n                    )\n                    return entity\n                if str(uuid_from_title) != str(entity.uuid):\n                    raise ValueError(\n                        f\"UUID mismatch: Page UUID: {uuid_from_title}, \"\n                        f\"Entity UUID: {entity.uuid}\"\n                    )\n                return entity\n            page_uuid = str(jsondata.get(\"uuid\"))\n            entity_uuid = str(getattr(entity, \"uuid\", None))\n            if page_uuid != entity_uuid or page_uuid == str(None):\n                # Comparing string type UUIDs\n                raise ValueError(\n                    f\"UUID mismatch: Page UUID: {page_uuid}, Entity UUID: {entity_uuid}\"\n                )\n            return entity\n\n        def __init__(self, **data):\n            super().__init__(**data)\n            if self.namespace is None:\n                self.namespace = get_namespace(self.entity)\n            if self.namespace is None:\n                raise ValueError(\"Namespace could not be determined.\")\n            if not isinstance(self.policy, OSW.OverwriteClassParam):\n                self.policy = OSW.OverwriteClassParam(\n                    model=self.entity.__class__,\n                    overwrite=self.policy,\n                )\n\n    @staticmethod\n    def _apply_overwrite_policy(param: OSW._ApplyOverwriteParam) -&gt; WtPage:\n        if param.inplace:\n            page = param.page\n        else:\n            page = deepcopy(param.page)\n        entity_title = f\"{param.namespace}:{get_title(param.entity)}\"\n\n        def set_content(content_to_set: dict) -&gt; None:\n            if param.debug:\n                print(f\"content_to_set: {str(content_to_set)}\")\n            for slot_ in content_to_set.keys():\n                page.set_slot_content(slot_, content_to_set[slot_])\n\n        # Create a variable to hold the new content\n        new_content = {\n            # required for json parsing and header rendering\n            \"header\": \"{{#invoke:Entity|header}}\",\n            # required for footer rendering\n            \"footer\": \"{{#invoke:Entity|footer}}\",\n        }\n        # Take the shortcut if\n        # 1. page does not exist AND any setting of overwrite\n        # 2. overwrite is \"replace remote\"\n        if (\n            not page.exists\n            or param.policy.overwrite == AddOverwriteClassOptions.replace_remote\n            or param.offline is True\n        ):\n            # Use pydantic serialization, skip none values:\n            new_content[\"jsondata\"] = json.loads(param.entity.json(exclude_none=True))\n            if param.remove_empty:\n                remove_empty(new_content[\"jsondata\"])\n            set_content(new_content)\n            page.changed = True\n            return page  # Guard clause --&gt; exit function\n        # 3. pages does exist AND overwrite is \"keep existing\"\n        if (\n            page.exists\n            and param.policy.overwrite == AddOverwriteClassOptions.keep_existing\n        ):\n            print(\n                f\"Entity '{entity_title}' already exists and won't be stored \"\n                f\"with overwrite set to 'keep existing'!\"\n            )\n            return page  # Guard clause --&gt; exit function\n        # Apply the overwrite logic in any other case\n        # 4. If per_property was None  -&gt; overwrite will be used as a fallback\n        # 4.1 If overwrite is True ---&gt; overwrite existing properties\n        # 4.2 If overwrite is False --&gt; don't overwrite existing properties\n        # 4.3 If overwrite is \"only empty\" --&gt; overwrite existing properties if\n        #     they are empty\n        # * Download page\n        # * Merge slots selectively based on per_property\n\n        # Create variables to hold local and remote content prior to merging\n        local_content = {}\n        remote_content = {}\n        # Get the remote content\n        for slot in [\"jsondata\", \"header\", \"footer\"]:  # SLOTS:\n            remote_content[slot] = page.get_slot_content(slot)\n            # Todo: remote content does not contain properties that are not set\n        if param.remove_empty:\n            remove_empty(remote_content[\"jsondata\"])\n        if remote_content[\"header\"]:  # not None or {} or \"\"\n            new_content[\"header\"] = remote_content[\"header\"]\n        if remote_content[\"footer\"]:\n            new_content[\"footer\"] = remote_content[\"footer\"]\n        if param.debug:\n            print(f\"'remote_content': {str(remote_content)}\")\n        # Get the local content\n        # Properties that are not set in the local content will be set to None\n        # We want those not to be listed as keys\n        local_content[\"jsondata\"] = json.loads(param.entity.json(exclude_none=True))\n        if param.remove_empty:\n            remove_empty(local_content[\"jsondata\"])\n        if param.debug:\n            print(f\"'local_content': {str(local_content)}\")\n        # Apply the overwrite logic\n        # a) If there is a key in the remote content that is not in the local\n        #    content, we have to keep it\n        if remote_content[\"jsondata\"] is None:\n            remote_content[\"jsondata\"] = {}\n        new_content[\"jsondata\"] = remote_content[\"jsondata\"]\n        # new_content[\"jsondata\"] = {\n        #     key: value\n        #     for (key, value) in remote_content[\"jsondata\"].items()\n        #     if key not in local_content[\"jsondata\"].keys()\n        # }\n        if param.debug:\n            print(f\"'New content' after 'remote' update: {str(new_content)}\")\n        # b) If there is a key in the local content that is not in the remote\n        #    content, we have to keep it\n        new_content[\"jsondata\"].update(\n            {\n                key: value\n                for (key, value) in local_content[\"jsondata\"].items()\n                if key not in remote_content[\"jsondata\"].keys()\n            }\n        )\n        if param.debug:\n            print(f\"'New content' after 'local' update: {str(new_content)}\")\n        # c) If there is a key in both contents, we have to apply the overwrite\n        #    logic\n        # todo: include logic for hidden and read_only properties!\n        new_content[\"jsondata\"].update(\n            {\n                key: value\n                for (key, value) in local_content[\"jsondata\"].items()\n                if param.policy.get_overwrite_setting(key) == OverwriteOptions.true\n            }\n        )\n        if param.debug:\n            print(f\"'New content' after 'True' update: {str(new_content)}\")\n        new_content[\"jsondata\"].update(\n            {\n                key: value\n                for (key, value) in remote_content[\"jsondata\"].items()\n                if param.policy.get_overwrite_setting(key) == OverwriteOptions.false\n            }\n        )\n        if param.debug:\n            print(f\"'New content' after 'False' update: {str(new_content)}\")\n        new_content[\"jsondata\"].update(\n            {\n                key: value\n                for (key, value) in local_content[\"jsondata\"].items()\n                if (\n                    param.policy.get_overwrite_setting(key)\n                    == OverwriteOptions.only_empty\n                    and is_empty(remote_content[\"jsondata\"].get(key))\n                )\n            }\n        )\n        if param.debug:\n            print(f\"'New content' after 'only empty' update: {str(new_content)}\")\n            print(f\"'New content' to be stored: {str(new_content)}\")\n        set_content(new_content)\n        return page  # Guard clause --&gt; exit function\n\n    class StoreEntityParam(OswBaseModel):\n        entities: Union[OswBaseModel, List[OswBaseModel]]  # actually model.Entity\n        \"\"\"The entities to store. Can be a single entity or a list of entities.\"\"\"\n        namespace: Optional[str]\n        \"\"\"The namespace of the entities. If not set, the namespace is derived from the\n        entity.\"\"\"\n        parallel: Optional[bool] = None\n        \"\"\"If set to True, the entities are stored in parallel.\"\"\"\n        overwrite: Optional[OVERWRITE_CLASS_OPTIONS] = \"keep existing\"\n        \"\"\"If no class specific overwrite setting is set, this setting is used.\"\"\"\n        overwrite_per_class: Optional[List[OSW.OverwriteClassParam]] = None\n        \"\"\"A list of OverwriteClassParam objects. If a class specific overwrite setting\n        is set, this setting is used.\n        \"\"\"\n        remove_empty: Optional[bool] = True\n        \"\"\"If true, remove key with an empty string value from the jsondata.\"\"\"\n        change_id: Optional[str] = None\n        \"\"\"ID to document the change. Entities within the same store_entity() call will\n        share the same change_id. This parameter can also be used to link multiple\n        store_entity() calls.\"\"\"\n        bot_edit: Optional[bool] = True\n        \"\"\"Mark the edit as bot edit,\n        which hides the edit from the recent changes in the default filer\"\"\"\n        edit_comment: Optional[str] = None\n        \"\"\"Additional comment to explain the edit.\"\"\"\n        meta_category_title: Optional[Union[str, List[str]]] = \"Category:Category\"\n        debug: Optional[bool] = False\n        offline: Optional[bool] = False\n        \"\"\"If set to True, the processed entities are not upload but only returned as WtPages.\n        Can be used to create WtPage objects from entities without uploading them.\"\"\"\n        _overwrite_per_class: Dict[str, Dict[str, OSW.OverwriteClassParam]] = (\n            PrivateAttr()\n        )\n        \"\"\"Private attribute, for internal use only. Use 'overwrite_per_class'\n        instead.\"\"\"\n\n        def __init__(self, **data):\n            super().__init__(**data)\n            if not isinstance(self.entities, list):\n                self.entities = [self.entities]\n            if self.change_id is None:\n                self.change_id = str(uuid4())\n            for entity in self.entities:\n                if getattr(entity, \"meta\", None) is None:\n                    entity.meta = model.Meta()\n                if entity.meta.change_id is None:\n                    entity.meta.change_id = []\n                if self.change_id not in entity.meta.change_id:\n                    entity.meta.change_id.append(self.change_id)\n            if len(self.entities) &gt; 5 and self.parallel is None:\n                self.parallel = True\n            if self.parallel is None:\n                self.parallel = (\n                    True  # Set to True after implementation of asynchronous upload\n                )\n            if self.overwrite is None:\n                self.overwrite = self.__fields__[\"overwrite\"].get_default()\n            self._overwrite_per_class = {\"by name\": {}, \"by type\": {}}\n            if self.overwrite_per_class is not None:\n                for param in self.overwrite_per_class:\n                    model_name = param.model.__name__\n                    model_type = param.model.__fields__[\"type\"].get_default()[0]\n                    if (\n                        model_name in self._overwrite_per_class[\"by name\"].keys()\n                        or model_type in self._overwrite_per_class[\"by type\"].keys()\n                    ):\n                        raise ValueError(\n                            f\"More than one OverwriteClassParam for the class \"\n                            f\"'{model_type}' ({model_name}) has been passed in the \"\n                            f\"list to 'overwrite_per_class'!\"\n                        )\n                    self._overwrite_per_class[\"by name\"][model_name] = param\n                    self._overwrite_per_class[\"by type\"][model_type] = param\n\n    class StoreEntityResult(OswBaseModel):\n        \"\"\"Result of store_entity()\"\"\"\n\n        change_id: str\n        \"\"\"The ID of the change\"\"\"\n        pages: Dict[str, WtPage]\n        \"\"\"The pages that have been stored\"\"\"\n\n        class Config:\n            arbitrary_types_allowed = True\n\n    def store_entity(\n        self, param: Union[StoreEntityParam, OswBaseModel, List[OswBaseModel]]\n    ) -&gt; StoreEntityResult:\n        \"\"\"stores the given dataclass instance as OSW page by calling BaseModel.json()\n\n        Parameters\n        ----------\n        param:\n            StoreEntityParam, the dataclass instance or a list of instances\n        \"\"\"\n        if isinstance(param, model.Entity):\n            param = OSW.StoreEntityParam(entities=[param])\n        if isinstance(param, list):\n            param = OSW.StoreEntityParam(entities=param)\n        if not isinstance(param.entities, list):\n            param.entities = [param.entities]\n\n        param: OSW.StoreEntityParam = param\n\n        max_index = len(param.entities)\n        created_pages = {}\n\n        meta_category_templates = {}\n        if param.namespace == \"Category\":\n            meta_category_titles = param.meta_category_title\n            if not isinstance(meta_category_titles, list):\n                meta_category_titles = [meta_category_titles]\n            meta_category_template_strs = {}\n            # We have to do this iteratively to support meta categories inheritance\n            while meta_category_titles is not None and len(meta_category_titles) &gt; 0:\n                meta_categories = self.site.get_page(\n                    WtSite.GetPageParam(titles=meta_category_titles)\n                ).pages\n                for meta_category in meta_categories:\n                    meta_category_template_strs[meta_category.title] = (\n                        meta_category.get_slot_content(\"schema_template\")\n                    )\n\n                meta_category_titles = meta_category.get_slot_content(\"jsondata\").get(\n                    \"subclass_of\"\n                )\n\n            for title in meta_category_template_strs.keys():\n                meta_category_template_str = meta_category_template_strs[title]\n                if meta_category_template_str:\n                    meta_category_templates[title] = compile_handlebars_template(\n                        meta_category_template_str\n                    )\n            # inverse order to have the most generic template first\n            meta_category_templates = dict(reversed(meta_category_templates.items()))\n\n        def store_entity_(\n            entity_: model.Entity,\n            namespace_: str = None,\n            index: int = None,\n            overwrite_class_param: OSW.OverwriteClassParam = None,\n        ) -&gt; None:\n            title_ = get_title(entity_)\n            if namespace_ is None:\n                namespace_ = get_namespace(entity_)\n            if namespace_ is None or title_ is None:\n                print(\"Error: Unsupported entity type\")\n                return\n            if overwrite_class_param is None:\n                raise TypeError(\"'overwrite_class_param' must not be None!\")\n            entity_title = namespace_ + \":\" + title_\n            page = self._apply_overwrite_policy(\n                OSW._ApplyOverwriteParam(\n                    page=WtPage(\n                        wtSite=self.site, title=entity_title, do_init=not param.offline\n                    ),\n                    entity=entity_,\n                    namespace=namespace_,\n                    policy=overwrite_class_param,\n                    remove_empty=param.remove_empty,\n                    debug=param.debug,\n                    offline=param.offline,\n                )\n            )\n            if len(meta_category_templates.keys()) &gt; 0:\n                generated_schemas = {}\n                try:\n                    jsondata = page.get_slot_content(\"jsondata\")\n                    if param.remove_empty:\n                        remove_empty(jsondata)\n\n                    for key in meta_category_templates:\n                        meta_category_template = meta_category_templates[key]\n                        schema_str = eval_compiled_handlebars_template(\n                            meta_category_template,\n                            escape_json_strings(jsondata),\n                            {\n                                \"_page_title\": entity_title,  # Legacy\n                                \"_current_subject_\": entity_title,\n                            },\n                        )\n                        generated_schemas[key] = json.loads(schema_str)\n                except Exception as e:\n                    print(f\"Schema generation from template failed for {entity_}: {e}\")\n\n                mode = AggregateGeneratedSchemasParamMode.ROOT_LEVEL\n                # Put generated schema in definitions section,\n                #  currently only enabled for Characteristics\n                if hasattr(model, \"CharacteristicType\") and isinstance(\n                    entity_, model.CharacteristicType\n                ):\n                    mode = AggregateGeneratedSchemasParamMode.DEFINITIONS_SECTION\n\n                new_schema = aggregate_generated_schemas(\n                    AggregateGeneratedSchemasParam(\n                        schema=page.get_slot_content(\"jsonschema\"),\n                        generated_schemas=generated_schemas,\n                        mode=mode,\n                    )\n                ).aggregated_schema\n                page.set_slot_content(\"jsonschema\", new_schema)\n            if param.offline is False:\n                page.edit(\n                    param.edit_comment, bot_edit=param.bot_edit\n                )  # will set page.changed if the content of the page has changed\n            if not param.offline and page.changed:\n                if index is None:\n                    print(f\"Entity stored at '{page.get_url()}'.\")\n                else:\n                    print(\n                        f\"({index + 1}/{max_index}) Entity stored at \"\n                        f\"'{page.get_url()}'.\"\n                    )\n            created_pages[page.title] = page\n\n        sorted_entities = OSW.sort_list_of_entities_by_class(param.entities)\n        print(\n            \"Entities to be uploaded have been sorted according to their type.\\n\"\n            \"If you would like to overwrite existing entities or properties, \"\n            \"pass a StoreEntityParam to store_entity() with \"\n            \"attribute 'overwrite' or 'overwrite_per_class' set to, e.g., \"\n            \"True.\"\n        )\n\n        class UploadObject(BaseModel):\n            entity: OswBaseModel\n            # Actually model.Entity but this causes the \"type\" error\n            namespace: Optional[str]\n            index: int\n            overwrite_class_param: OSW.OverwriteClassParam\n\n        upload_object_list: List[UploadObject] = []\n\n        upload_index = 0\n        for class_type, entities in sorted_entities.by_type.items():\n            # Try to get a class specific overwrite setting\n            class_param = param._overwrite_per_class[\"by type\"].get(class_type, None)\n            if class_param is None:\n                entity_model = entities[0].__class__\n                class_param = OSW.OverwriteClassParam(\n                    model=entity_model,\n                    overwrite=param.overwrite,\n                )\n                if param.debug:\n                    print(\n                        f\"Now adding entities of class type '{class_type}' \"\n                        f\"({entity_model.__name__}) to upload list. No class specific\"\n                        f\" overwrite setting found. Using fallback option '\"\n                        f\"{param.overwrite}' for all entities of this class.\"\n                    )\n            for entity in entities:\n                upload_object_list.append(\n                    UploadObject(\n                        entity=entity,\n                        namespace=param.namespace,\n                        index=upload_index,\n                        overwrite_class_param=class_param,\n                    )\n                )\n                upload_index += 1\n\n        def handle_upload_object_(upload_object: UploadObject) -&gt; None:\n            store_entity_(\n                upload_object.entity,\n                upload_object.namespace,\n                upload_object.index,\n                upload_object.overwrite_class_param,\n            )\n\n        if param.parallel:\n            _ = parallelize(\n                handle_upload_object_, upload_object_list, flush_at_end=param.debug\n            )\n        else:\n            _ = [\n                handle_upload_object_(upload_object)\n                for upload_object in upload_object_list\n            ]\n        return OSW.StoreEntityResult(change_id=param.change_id, pages=created_pages)\n\n    class DeleteEntityParam(OswBaseModel):\n        entities: Union[OswBaseModel, List[OswBaseModel]]\n        comment: Optional[str] = None\n        parallel: Optional[bool] = None\n        debug: Optional[bool] = False\n\n        def __init__(self, **data):\n            super().__init__(**data)\n            if not isinstance(self.entities, list):\n                self.entities = [self.entities]\n            if len(self.entities) &gt; 5 and self.parallel is None:\n                self.parallel = True\n            if self.parallel is None:\n                self.parallel = False\n\n    def delete_entity(\n        self,\n        entity: Union[OswBaseModel, List[OswBaseModel], DeleteEntityParam],\n        comment: str = None,\n    ):\n        \"\"\"Deletes the given entity/entities from the OSW instance.\"\"\"\n        if not isinstance(entity, OSW.DeleteEntityParam):\n            entity = OSW.DeleteEntityParam(entities=entity)\n        if comment is not None:\n            entity.comment = comment\n\n        def delete_entity_(entity_, comment_: str = None):\n            \"\"\"Deletes the given entity from the OSW instance.\n\n            Parameters\n            ----------\n            entity_:\n                The dataclass instance to delete\n            comment_:\n                Command for the change log, by default None\n            \"\"\"\n            title_ = None\n            namespace_ = None\n            if hasattr(entity_, \"meta\"):\n                if entity_.meta and entity_.meta.wiki_page:\n                    if entity_.meta.wiki_page.title:\n                        title_ = entity_.meta.wiki_page.title\n                    if entity_.meta.wiki_page.namespace:\n                        namespace_ = entity_.meta.wiki_page.namespace\n            if namespace_ is None:\n                namespace_ = get_namespace(entity_)\n            if title_ is None:\n                title_ = OSW.get_osw_id(entity_.uuid)\n            if namespace_ is None or title_ is None:\n                print(\"Error: Unsupported entity type\")\n                return\n            entity_title = namespace_ + \":\" + title_\n            page = self.site.get_page(WtSite.GetPageParam(titles=[entity_title])).pages[\n                0\n            ]\n\n            if page.exists:\n                page.delete(comment_)\n                print(\"Entity deleted: \" + page.get_url())\n            else:\n                print(f\"Entity '{entity_title}' does not exist!\")\n\n        if entity.parallel:\n            _ = parallelize(\n                delete_entity_,\n                entity.entities,\n                flush_at_end=entity.debug,\n                comment_=entity.comment,\n            )\n        else:\n            _ = [delete_entity_(e, entity.comment) for e in entity.entities]\n\n    class QueryInstancesParam(OswBaseModel):\n        categories: Union[\n            Union[str, Type[OswBaseModel]], List[Union[str, Type[OswBaseModel]]]\n        ]\n        parallel: Optional[bool] = None\n        debug: Optional[bool] = False\n        limit: Optional[int] = 1000\n        _category_string_parts: List[Dict[str, str]] = PrivateAttr()\n        _titles: List[str] = PrivateAttr()\n\n        @staticmethod\n        def get_full_page_name_parts(\n            category_: Union[str, Type[OswBaseModel]]\n        ) -&gt; Dict[str, str]:\n            error_msg = (\n                f\"Category must be a string like 'Category:&lt;category name&gt;' or a \"\n                f\"dataclass subclass with a 'type' attribute. This error occurred on \"\n                f\"'{str(category_)}'\"\n            )\n            if isinstance(category_, str):\n                string_to_split = category_\n            elif issubclass(category_, OswBaseModel):\n                type_ = category_.__fields__.get(\"type\")\n                if getattr(type_, \"default\", None) is None:\n                    raise TypeError(error_msg)\n                string_to_split = type_.default[0]\n            else:\n                raise TypeError(error_msg)\n            if \"Category:\" not in string_to_split:\n                raise TypeError(error_msg)\n            return {\n                \"namespace\": string_to_split.split(\":\")[0],\n                \"title\": string_to_split.split(\":\")[-1],\n            }\n\n        def __init__(self, **data):\n            super().__init__(**data)\n            if not isinstance(self.categories, list):\n                self.categories = [self.categories]\n            if len(self.categories) &gt; 5 and self.parallel is None:\n                self.parallel = True\n            if self.parallel is None:\n                self.parallel = False\n            self._category_string_parts = [\n                OSW.QueryInstancesParam.get_full_page_name_parts(cat)\n                for cat in self.categories\n            ]\n            self._titles = [parts[\"title\"] for parts in self._category_string_parts]\n\n    def query_instances(\n        self, category: Union[str, Type[OswBaseModel], OSW.QueryInstancesParam]\n    ) -&gt; List[str]:\n        if not isinstance(category, OSW.QueryInstancesParam):\n            category = OSW.QueryInstancesParam(categories=category)\n        page_titles = category._titles\n        search_param = SearchParam(\n            query=[f\"[[HasType::Category:{page_title}]]\" for page_title in page_titles],\n            **category.dict(\n                exclude={\"categories\", \"_category_string_parts\", \"_titles\"}\n            ),\n        )\n        full_page_titles = self.site.semantic_search(search_param)\n        return full_page_titles\n\n    class JsonLdMode(str, Enum):\n        \"\"\"enum for jsonld processing mode\"\"\"\n\n        expand = \"expand\"\n        flatten = \"flatten\"\n        compact = \"compact\"\n        frame = \"frame\"\n\n    class ExportJsonLdParams(OswBaseModel):\n        context_loader_config: Optional[WtSite.JsonLdContextLoaderParams] = None\n        \"\"\"The configuration for the JSON-LD context loader.\"\"\"\n        entities: Union[OswBaseModel, List[OswBaseModel]]\n        \"\"\"The entities to convert to JSON-LD. Can be a single entity or a list of\n        entities.\"\"\"\n        id_keys: Optional[List[str]] = Field(default=[\"osw_id\"])\n        \"\"\"The keys to use as @id in the JSON-LD output. If not found in the entity at root\n        level, the full page title is used.\"\"\"\n        resolve_context: Optional[bool] = True\n        \"\"\"If True, remote context URLs are resolved.\"\"\"\n        mode: Optional[OSW.JsonLdMode] = \"expand\"\n        \"\"\"The JSON-LD processing mode to apply if resolve_context is True.\"\"\"\n        context: Optional[Union[str, list, Dict[str, Any]]] = None\n        \"\"\"The JSON-LD context to apply. Replaces any existing context.\"\"\"\n        additional_context: Optional[Union[str, list, Dict[str, Any]]] = None\n        \"\"\"The JSON-LD context to apply on top of the existing context.\"\"\"\n        frame: Optional[Dict[str, Any]] = None\n        \"\"\"The JSON-LD frame to use for framed mode. If not set, the existing context is used\"\"\"\n        build_rdf_graph: Optional[bool] = False\n        \"\"\"If True, the output is a graph.\"\"\"\n        debug: Optional[bool] = False\n\n        def __init__(self, **data):\n            super().__init__(**data)\n            if not isinstance(self.entities, list):\n                self.entities = [self.entities]\n\n    class ExportJsonLdResult(OswBaseModel):\n        documents: List[Union[Dict[str, Any]]]\n        \"\"\"A single JSON-LD document per entity\"\"\"\n        graph_document: Dict[str, Any] = None\n        \"\"\"A single JSON-LD document with a @graph element containing all entities\"\"\"\n        graph: rdflib.Graph = None\n        \"\"\"RDF graph containing all entities. Build only if build_rdf_graph is True\"\"\"\n\n        class Config:\n            arbitrary_types_allowed = True\n\n    def export_jsonld(self, params: ExportJsonLdParams) -&gt; ExportJsonLdResult:\n        \"\"\"Exports the given entity/entities as JSON-LD.\"\"\"\n\n        if params.resolve_context:\n            jsonld.set_document_loader(\n                self.site.get_jsonld_context_loader(params.context_loader_config)\n            )\n\n        documents = []\n        graph_document = {\"@graph\": []}\n        graph = None\n        if params.build_rdf_graph:\n            graph = rdflib.Graph()\n            prefixes = self.site.get_prefix_dict()\n            for prefix in prefixes:\n                graph.bind(prefix, prefixes[prefix])\n\n        for e in params.entities:\n            data = json.loads(e.json(exclude_none=True, indent=4, ensure_ascii=False))\n\n            data[\"@context\"] = []\n            if params.id_keys is not None:\n                # append \"@id\" mappings to the context in an additional object\n                id_mapping = {}\n                for k in params.id_keys:\n                    id_mapping[k] = \"@id\"\n                data[\"@context\"].append(id_mapping)\n            if params.context is None:\n                for t in e.type:\n                    data[\"@context\"].append(\"/wiki/\" + t)\n                if params.context is not None:\n                    data[\"@context\"].append(params.context)\n            else:\n                data[\"@context\"].append(self.site.get_jsonld_context_prefixes())\n                if isinstance(params.context, list):\n                    data[\"@context\"].extend(params.context)\n                else:\n                    data[\"@context\"].append(params.context)\n            if params.additional_context is not None:\n                if data[\"@context\"] is None:\n                    data[\"@context\"] = []\n                elif not isinstance(data[\"@context\"], list):\n                    data[\"@context\"] = [data[\"@context\"]]\n                data[\"@context\"].append(params.additional_context)\n\n            # if none of the id_keys is found, use the full title\n            if not any(k in data for k in params.id_keys):\n                data[\"@id\"] = get_full_title(e)\n\n            if params.resolve_context:\n                graph_document[\"@graph\"].append(jsonld.expand(data))\n                if params.mode == \"expand\":\n                    data = jsonld.expand(data)\n                    if isinstance(data, list) and len(data) &gt; 0:\n                        data = data[0]\n                elif params.mode == \"flatten\":\n                    data = jsonld.flatten(data)\n                elif params.mode == \"compact\":\n                    # data = jsonld.expand(data)\n                    # if isinstance(data, list): data = data[0]\n                    data = jsonld.compact(\n                        data,\n                        data[\"@context\"] if params.context is None else params.context,\n                    )\n                elif params.mode == \"frame\":\n                    data = jsonld.frame(\n                        data,\n                        (\n                            {\"@context\": data[\"@context\"]}\n                            if params.frame is None\n                            else params.frame\n                        ),\n                    )\n\n                if params.build_rdf_graph:\n                    graph.parse(data=json.dumps(data), format=\"json-ld\")\n\n            documents.append(data)\n\n        result = OSW.ExportJsonLdResult(\n            documents=documents, graph_document=graph_document, graph=graph\n        )\n        return result\n</code></pre>"},{"location":"osw/#osw.core.OSW.mw_site","title":"<code>mw_site</code>  <code>property</code>","text":"<p>Returns the mwclient Site object of the OSW instance.</p>"},{"location":"osw/#osw.core.OSW.ExportJsonLdParams","title":"<code>ExportJsonLdParams</code>","text":"<p>               Bases: <code>OswBaseModel</code></p> Source code in <code>src/osw/core.py</code> <pre><code>class ExportJsonLdParams(OswBaseModel):\n    context_loader_config: Optional[WtSite.JsonLdContextLoaderParams] = None\n    \"\"\"The configuration for the JSON-LD context loader.\"\"\"\n    entities: Union[OswBaseModel, List[OswBaseModel]]\n    \"\"\"The entities to convert to JSON-LD. Can be a single entity or a list of\n    entities.\"\"\"\n    id_keys: Optional[List[str]] = Field(default=[\"osw_id\"])\n    \"\"\"The keys to use as @id in the JSON-LD output. If not found in the entity at root\n    level, the full page title is used.\"\"\"\n    resolve_context: Optional[bool] = True\n    \"\"\"If True, remote context URLs are resolved.\"\"\"\n    mode: Optional[OSW.JsonLdMode] = \"expand\"\n    \"\"\"The JSON-LD processing mode to apply if resolve_context is True.\"\"\"\n    context: Optional[Union[str, list, Dict[str, Any]]] = None\n    \"\"\"The JSON-LD context to apply. Replaces any existing context.\"\"\"\n    additional_context: Optional[Union[str, list, Dict[str, Any]]] = None\n    \"\"\"The JSON-LD context to apply on top of the existing context.\"\"\"\n    frame: Optional[Dict[str, Any]] = None\n    \"\"\"The JSON-LD frame to use for framed mode. If not set, the existing context is used\"\"\"\n    build_rdf_graph: Optional[bool] = False\n    \"\"\"If True, the output is a graph.\"\"\"\n    debug: Optional[bool] = False\n\n    def __init__(self, **data):\n        super().__init__(**data)\n        if not isinstance(self.entities, list):\n            self.entities = [self.entities]\n</code></pre>"},{"location":"osw/#osw.core.OSW.ExportJsonLdParams.additional_context","title":"<code>additional_context = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The JSON-LD context to apply on top of the existing context.</p>"},{"location":"osw/#osw.core.OSW.ExportJsonLdParams.build_rdf_graph","title":"<code>build_rdf_graph = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>If True, the output is a graph.</p>"},{"location":"osw/#osw.core.OSW.ExportJsonLdParams.context","title":"<code>context = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The JSON-LD context to apply. Replaces any existing context.</p>"},{"location":"osw/#osw.core.OSW.ExportJsonLdParams.context_loader_config","title":"<code>context_loader_config = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The configuration for the JSON-LD context loader.</p>"},{"location":"osw/#osw.core.OSW.ExportJsonLdParams.entities","title":"<code>entities</code>  <code>instance-attribute</code>","text":"<p>The entities to convert to JSON-LD. Can be a single entity or a list of entities.</p>"},{"location":"osw/#osw.core.OSW.ExportJsonLdParams.frame","title":"<code>frame = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The JSON-LD frame to use for framed mode. If not set, the existing context is used</p>"},{"location":"osw/#osw.core.OSW.ExportJsonLdParams.id_keys","title":"<code>id_keys = Field(default=['osw_id'])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The keys to use as @id in the JSON-LD output. If not found in the entity at root level, the full page title is used.</p>"},{"location":"osw/#osw.core.OSW.ExportJsonLdParams.mode","title":"<code>mode = 'expand'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The JSON-LD processing mode to apply if resolve_context is True.</p>"},{"location":"osw/#osw.core.OSW.ExportJsonLdParams.resolve_context","title":"<code>resolve_context = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>If True, remote context URLs are resolved.</p>"},{"location":"osw/#osw.core.OSW.ExportJsonLdResult","title":"<code>ExportJsonLdResult</code>  <code>dataclass</code>","text":"<p>               Bases: <code>OswBaseModel</code></p> Source code in <code>src/osw/core.py</code> <pre><code>class ExportJsonLdResult(OswBaseModel):\n    documents: List[Union[Dict[str, Any]]]\n    \"\"\"A single JSON-LD document per entity\"\"\"\n    graph_document: Dict[str, Any] = None\n    \"\"\"A single JSON-LD document with a @graph element containing all entities\"\"\"\n    graph: rdflib.Graph = None\n    \"\"\"RDF graph containing all entities. Build only if build_rdf_graph is True\"\"\"\n\n    class Config:\n        arbitrary_types_allowed = True\n</code></pre>"},{"location":"osw/#osw.core.OSW.ExportJsonLdResult.documents","title":"<code>documents</code>  <code>instance-attribute</code>","text":"<p>A single JSON-LD document per entity</p>"},{"location":"osw/#osw.core.OSW.ExportJsonLdResult.graph","title":"<code>graph = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>RDF graph containing all entities. Build only if build_rdf_graph is True</p>"},{"location":"osw/#osw.core.OSW.ExportJsonLdResult.graph_document","title":"<code>graph_document = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A single JSON-LD document with a @graph element containing all entities</p>"},{"location":"osw/#osw.core.OSW.FetchSchemaMode","title":"<code>FetchSchemaMode</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Modes of the FetchSchemaParam class</p> <p>Attributes:</p> Name Type Description <code>append</code> <p>append to the current model</p> <code>replace</code> <p>replace the current model</p> Source code in <code>src/osw/core.py</code> <pre><code>class FetchSchemaMode(Enum):\n    \"\"\"Modes of the FetchSchemaParam class\n\n    Attributes\n    ----------\n    append:\n        append to the current model\n    replace:\n        replace the current model\n    \"\"\"\n\n    append = \"append\"  # append to the current model\n    replace = \"replace\"  # replace the current model\n</code></pre>"},{"location":"osw/#osw.core.OSW.FetchSchemaParam","title":"<code>FetchSchemaParam</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Param for fetch_schema()</p> <p>Attributes:</p> Name Type Description <code>schema_title</code> <code>Optional[Union[List[str], str]]</code> <p>one or multiple titles (wiki page name) of schemas (default: Category:Item)</p> <code>mode</code> <code>Optional[str]</code> <p>append or replace (default) current schema, see FetchSchemaMode</p> Source code in <code>src/osw/core.py</code> <pre><code>class FetchSchemaParam(BaseModel):\n    \"\"\"Param for fetch_schema()\n\n    Attributes\n    ----------\n    schema_title:\n        one or multiple titles (wiki page name) of schemas (default: Category:Item)\n    mode:\n        append or replace (default) current schema, see FetchSchemaMode\n    \"\"\"\n\n    schema_title: Optional[Union[List[str], str]] = \"Category:Item\"\n    mode: Optional[str] = (\n        \"replace\"\n        # type 'FetchSchemaMode' requires: 'from __future__ import annotations'\n    )\n    legacy_generator: Optional[bool] = False\n    \"\"\"uses legacy command line for code generation if true\"\"\"\n</code></pre>"},{"location":"osw/#osw.core.OSW.FetchSchemaParam.legacy_generator","title":"<code>legacy_generator = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>uses legacy command line for code generation if true</p>"},{"location":"osw/#osw.core.OSW.JsonLdMode","title":"<code>JsonLdMode</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>enum for jsonld processing mode</p> Source code in <code>src/osw/core.py</code> <pre><code>class JsonLdMode(str, Enum):\n    \"\"\"enum for jsonld processing mode\"\"\"\n\n    expand = \"expand\"\n    flatten = \"flatten\"\n    compact = \"compact\"\n    frame = \"frame\"\n</code></pre>"},{"location":"osw/#osw.core.OSW.LoadEntityParam","title":"<code>LoadEntityParam</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Param for load_entity()</p> Source code in <code>src/osw/core.py</code> <pre><code>class LoadEntityParam(BaseModel):\n    \"\"\"Param for load_entity()\"\"\"\n\n    titles: Union[str, List[str]]\n    \"\"\"The pages titles to load - one or multiple titles (wiki page name) of\n    entities\"\"\"\n    autofetch_schema: Optional[bool] = True\n    \"\"\"If true, load the corresponding schemas /\n    categories ad-hoc if not already present\"\"\"\n    model_to_use: Optional[Type[OswBaseModel]] = None\n    \"\"\"If provided this model will be used to create an entity (instance of the\n    model), instead of instantiating the autofetched schema.\"\"\"\n    remove_empty: Optional[bool] = True\n    \"\"\"If true, remove key with an empty string, list, dict or set as value\n    from the jsondata.\"\"\"\n    disable_cache: bool = False\n    \"\"\"If true, disable the cache for the loading process\"\"\"\n\n    def __init__(self, **data):\n        super().__init__(**data)\n        if not isinstance(self.titles, list):\n            self.titles = [self.titles]\n</code></pre>"},{"location":"osw/#osw.core.OSW.LoadEntityParam.autofetch_schema","title":"<code>autofetch_schema = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>If true, load the corresponding schemas / categories ad-hoc if not already present</p>"},{"location":"osw/#osw.core.OSW.LoadEntityParam.disable_cache","title":"<code>disable_cache = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>If true, disable the cache for the loading process</p>"},{"location":"osw/#osw.core.OSW.LoadEntityParam.model_to_use","title":"<code>model_to_use = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>If provided this model will be used to create an entity (instance of the model), instead of instantiating the autofetched schema.</p>"},{"location":"osw/#osw.core.OSW.LoadEntityParam.remove_empty","title":"<code>remove_empty = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>If true, remove key with an empty string, list, dict or set as value from the jsondata.</p>"},{"location":"osw/#osw.core.OSW.LoadEntityParam.titles","title":"<code>titles</code>  <code>instance-attribute</code>","text":"<p>The pages titles to load - one or multiple titles (wiki page name) of entities</p>"},{"location":"osw/#osw.core.OSW.LoadEntityResult","title":"<code>LoadEntityResult</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Result of load_entity()</p> Source code in <code>src/osw/core.py</code> <pre><code>class LoadEntityResult(BaseModel):\n    \"\"\"Result of load_entity()\"\"\"\n\n    entities: Union[model.Entity, List[model.Entity]]\n    \"\"\"The dataclass instance(s)\"\"\"\n</code></pre>"},{"location":"osw/#osw.core.OSW.LoadEntityResult.entities","title":"<code>entities</code>  <code>instance-attribute</code>","text":"<p>The dataclass instance(s)</p>"},{"location":"osw/#osw.core.OSW.OverwriteClassParam","title":"<code>OverwriteClassParam</code>","text":"<p>               Bases: <code>OswBaseModel</code></p> Source code in <code>src/osw/core.py</code> <pre><code>class OverwriteClassParam(OswBaseModel):\n    model: Type[OswBaseModel]  # ModelMetaclass\n    \"\"\"The model class for which this is the overwrite params object.\"\"\"\n    overwrite: Optional[OVERWRITE_CLASS_OPTIONS] = False\n    \"\"\"Defines the overall overwriting behavior. Used for any property if the\n    property specific setting is not set.\"\"\"\n    per_property: Optional[Dict[str, OverwriteOptions]] = None\n    \"\"\"A key (property name) - value (overwrite setting) pair.\"\"\"\n    _per_property: Dict[str, OVERWRITE_CLASS_OPTIONS] = PrivateAttr()\n    \"\"\"Private property, for internal use only. Use 'per_property' instead\"\"\"\n\n    @validator(\"per_property\")\n    def validate_per_property(cls, per_property, values):\n        model_ = values.get(\"model\")\n        field_names = list(model_.__fields__.keys())\n        keys = per_property.keys()\n        if not all(key in field_names for key in keys):\n            missing_keys = [key for key in keys if key not in field_names]\n            raise ValueError(\n                f\"Property not found in model: {', '.join(missing_keys)}\"\n            )\n\n        return per_property\n\n    def __setattr__(self, key, value):\n        \"\"\"Called when setting an attribute\"\"\"\n        super().__setattr__(key, value)\n        if key == \"per_property\":\n            # compare value and self.per_property\n            if value != self.per_property and value is not None:\n                self._per_property = {\n                    field_name: value.get(field_name, self.overwrite)\n                    for field_name in self.model.__fields__.keys()\n                }\n        elif key == \"overwrite\":\n            if self.per_property is not None:\n                self._per_property = {\n                    field_name: self.per_property.get(field_name, self.overwrite)\n                    for field_name in self.model.__fields__.keys()\n                }\n        elif key == \"model\":\n            if self.per_property is not None:\n                self._per_property = {\n                    field_name: self.per_property.get(field_name, self.overwrite)\n                    for field_name in self.model.__fields__.keys()\n                }\n\n    def __init__(self, **data):\n        \"\"\"Called after validation. Sets the fallback for every property that\n        has not been specified in per_property.\"\"\"\n        super().__init__(**data)\n        per_property_ = {}\n        if self.per_property is not None:\n            per_property_ = self.per_property\n        self._per_property = {\n            field_name: per_property_.get(field_name, self.overwrite)\n            for field_name in self.model.__fields__.keys()\n        }\n        # todo: from class definition get properties with hidden /\n        #  read_only option  #  those can be safely overwritten - set the to True\n\n    def get_overwrite_setting(self, property_name: str) -&gt; OverwriteOptions:\n        \"\"\"Returns the fallback overwrite option for the given field name\"\"\"\n        return self._per_property.get(property_name, self.overwrite)\n</code></pre>"},{"location":"osw/#osw.core.OSW.OverwriteClassParam._per_property","title":"<code>_per_property = {field_name: per_property_.get(field_name, self.overwrite)for field_name in self.model.__fields__.keys()}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Private property, for internal use only. Use 'per_property' instead</p>"},{"location":"osw/#osw.core.OSW.OverwriteClassParam.model","title":"<code>model</code>  <code>instance-attribute</code>","text":"<p>The model class for which this is the overwrite params object.</p>"},{"location":"osw/#osw.core.OSW.OverwriteClassParam.overwrite","title":"<code>overwrite = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Defines the overall overwriting behavior. Used for any property if the property specific setting is not set.</p>"},{"location":"osw/#osw.core.OSW.OverwriteClassParam.per_property","title":"<code>per_property = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A key (property name) - value (overwrite setting) pair.</p>"},{"location":"osw/#osw.core.OSW.OverwriteClassParam.__init__","title":"<code>__init__(**data)</code>","text":"<p>Called after validation. Sets the fallback for every property that has not been specified in per_property.</p> Source code in <code>src/osw/core.py</code> <pre><code>def __init__(self, **data):\n    \"\"\"Called after validation. Sets the fallback for every property that\n    has not been specified in per_property.\"\"\"\n    super().__init__(**data)\n    per_property_ = {}\n    if self.per_property is not None:\n        per_property_ = self.per_property\n    self._per_property = {\n        field_name: per_property_.get(field_name, self.overwrite)\n        for field_name in self.model.__fields__.keys()\n    }\n</code></pre>"},{"location":"osw/#osw.core.OSW.OverwriteClassParam.__setattr__","title":"<code>__setattr__(key, value)</code>","text":"<p>Called when setting an attribute</p> Source code in <code>src/osw/core.py</code> <pre><code>def __setattr__(self, key, value):\n    \"\"\"Called when setting an attribute\"\"\"\n    super().__setattr__(key, value)\n    if key == \"per_property\":\n        # compare value and self.per_property\n        if value != self.per_property and value is not None:\n            self._per_property = {\n                field_name: value.get(field_name, self.overwrite)\n                for field_name in self.model.__fields__.keys()\n            }\n    elif key == \"overwrite\":\n        if self.per_property is not None:\n            self._per_property = {\n                field_name: self.per_property.get(field_name, self.overwrite)\n                for field_name in self.model.__fields__.keys()\n            }\n    elif key == \"model\":\n        if self.per_property is not None:\n            self._per_property = {\n                field_name: self.per_property.get(field_name, self.overwrite)\n                for field_name in self.model.__fields__.keys()\n            }\n</code></pre>"},{"location":"osw/#osw.core.OSW.OverwriteClassParam.get_overwrite_setting","title":"<code>get_overwrite_setting(property_name)</code>","text":"<p>Returns the fallback overwrite option for the given field name</p> Source code in <code>src/osw/core.py</code> <pre><code>def get_overwrite_setting(self, property_name: str) -&gt; OverwriteOptions:\n    \"\"\"Returns the fallback overwrite option for the given field name\"\"\"\n    return self._per_property.get(property_name, self.overwrite)\n</code></pre>"},{"location":"osw/#osw.core.OSW.SchemaRegistration","title":"<code>SchemaRegistration</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>dataclass param of register_schema()</p> Source code in <code>src/osw/core.py</code> <pre><code>class SchemaRegistration(BaseModel):\n    \"\"\"dataclass param of register_schema()\"\"\"\n\n    class Config:\n        arbitrary_types_allowed = True  # allow any class as type\n\n    model_cls: Type[OswBaseModel]\n    \"\"\"The model class\"\"\"\n    schema_uuid: str  # Optional[str] = model_cls.__uuid__\n    \"\"\"The schema uuid\"\"\"\n    schema_name: str  # Optional[str] = model_cls.__name__\n    \"\"\"The schema name\"\"\"\n    schema_bases: List[str] = Field(default=[\"Category:Item\"])\n    \"\"\"A list of base schemas (referenced by allOf)\"\"\"\n</code></pre>"},{"location":"osw/#osw.core.OSW.SchemaRegistration.model_cls","title":"<code>model_cls</code>  <code>instance-attribute</code>","text":"<p>The model class</p>"},{"location":"osw/#osw.core.OSW.SchemaRegistration.schema_bases","title":"<code>schema_bases = Field(default=['Category:Item'])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A list of base schemas (referenced by allOf)</p>"},{"location":"osw/#osw.core.OSW.SchemaRegistration.schema_name","title":"<code>schema_name</code>  <code>instance-attribute</code>","text":"<p>The schema name</p>"},{"location":"osw/#osw.core.OSW.SchemaRegistration.schema_uuid","title":"<code>schema_uuid</code>  <code>instance-attribute</code>","text":"<p>The schema uuid</p>"},{"location":"osw/#osw.core.OSW.SchemaUnregistration","title":"<code>SchemaUnregistration</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>dataclass param of register_schema()</p> Source code in <code>src/osw/core.py</code> <pre><code>class SchemaUnregistration(BaseModel):\n    \"\"\"dataclass param of register_schema()\"\"\"\n\n    class Config:\n        arbitrary_types_allowed = True  # allow any class as type\n\n    model_cls: Optional[Type[OswBaseModel]]\n    \"\"\"The model class\"\"\"\n    model_uuid: Optional[str]\n    \"\"\"The model uuid\"\"\"\n    comment: Optional[str]\n    \"\"\"The comment for the deletion, to be left behind\"\"\"\n</code></pre>"},{"location":"osw/#osw.core.OSW.SchemaUnregistration.comment","title":"<code>comment</code>  <code>instance-attribute</code>","text":"<p>The comment for the deletion, to be left behind</p>"},{"location":"osw/#osw.core.OSW.SchemaUnregistration.model_cls","title":"<code>model_cls</code>  <code>instance-attribute</code>","text":"<p>The model class</p>"},{"location":"osw/#osw.core.OSW.SchemaUnregistration.model_uuid","title":"<code>model_uuid</code>  <code>instance-attribute</code>","text":"<p>The model uuid</p>"},{"location":"osw/#osw.core.OSW.StoreEntityParam","title":"<code>StoreEntityParam</code>","text":"<p>               Bases: <code>OswBaseModel</code></p> Source code in <code>src/osw/core.py</code> <pre><code>class StoreEntityParam(OswBaseModel):\n    entities: Union[OswBaseModel, List[OswBaseModel]]  # actually model.Entity\n    \"\"\"The entities to store. Can be a single entity or a list of entities.\"\"\"\n    namespace: Optional[str]\n    \"\"\"The namespace of the entities. If not set, the namespace is derived from the\n    entity.\"\"\"\n    parallel: Optional[bool] = None\n    \"\"\"If set to True, the entities are stored in parallel.\"\"\"\n    overwrite: Optional[OVERWRITE_CLASS_OPTIONS] = \"keep existing\"\n    \"\"\"If no class specific overwrite setting is set, this setting is used.\"\"\"\n    overwrite_per_class: Optional[List[OSW.OverwriteClassParam]] = None\n    \"\"\"A list of OverwriteClassParam objects. If a class specific overwrite setting\n    is set, this setting is used.\n    \"\"\"\n    remove_empty: Optional[bool] = True\n    \"\"\"If true, remove key with an empty string value from the jsondata.\"\"\"\n    change_id: Optional[str] = None\n    \"\"\"ID to document the change. Entities within the same store_entity() call will\n    share the same change_id. This parameter can also be used to link multiple\n    store_entity() calls.\"\"\"\n    bot_edit: Optional[bool] = True\n    \"\"\"Mark the edit as bot edit,\n    which hides the edit from the recent changes in the default filer\"\"\"\n    edit_comment: Optional[str] = None\n    \"\"\"Additional comment to explain the edit.\"\"\"\n    meta_category_title: Optional[Union[str, List[str]]] = \"Category:Category\"\n    debug: Optional[bool] = False\n    offline: Optional[bool] = False\n    \"\"\"If set to True, the processed entities are not upload but only returned as WtPages.\n    Can be used to create WtPage objects from entities without uploading them.\"\"\"\n    _overwrite_per_class: Dict[str, Dict[str, OSW.OverwriteClassParam]] = (\n        PrivateAttr()\n    )\n    \"\"\"Private attribute, for internal use only. Use 'overwrite_per_class'\n    instead.\"\"\"\n\n    def __init__(self, **data):\n        super().__init__(**data)\n        if not isinstance(self.entities, list):\n            self.entities = [self.entities]\n        if self.change_id is None:\n            self.change_id = str(uuid4())\n        for entity in self.entities:\n            if getattr(entity, \"meta\", None) is None:\n                entity.meta = model.Meta()\n            if entity.meta.change_id is None:\n                entity.meta.change_id = []\n            if self.change_id not in entity.meta.change_id:\n                entity.meta.change_id.append(self.change_id)\n        if len(self.entities) &gt; 5 and self.parallel is None:\n            self.parallel = True\n        if self.parallel is None:\n            self.parallel = (\n                True  # Set to True after implementation of asynchronous upload\n            )\n        if self.overwrite is None:\n            self.overwrite = self.__fields__[\"overwrite\"].get_default()\n        self._overwrite_per_class = {\"by name\": {}, \"by type\": {}}\n        if self.overwrite_per_class is not None:\n            for param in self.overwrite_per_class:\n                model_name = param.model.__name__\n                model_type = param.model.__fields__[\"type\"].get_default()[0]\n                if (\n                    model_name in self._overwrite_per_class[\"by name\"].keys()\n                    or model_type in self._overwrite_per_class[\"by type\"].keys()\n                ):\n                    raise ValueError(\n                        f\"More than one OverwriteClassParam for the class \"\n                        f\"'{model_type}' ({model_name}) has been passed in the \"\n                        f\"list to 'overwrite_per_class'!\"\n                    )\n                self._overwrite_per_class[\"by name\"][model_name] = param\n                self._overwrite_per_class[\"by type\"][model_type] = param\n</code></pre>"},{"location":"osw/#osw.core.OSW.StoreEntityParam._overwrite_per_class","title":"<code>_overwrite_per_class = {'by name': {}, 'by type': {}}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Private attribute, for internal use only. Use 'overwrite_per_class' instead.</p>"},{"location":"osw/#osw.core.OSW.StoreEntityParam.bot_edit","title":"<code>bot_edit = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Mark the edit as bot edit, which hides the edit from the recent changes in the default filer</p>"},{"location":"osw/#osw.core.OSW.StoreEntityParam.change_id","title":"<code>change_id = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ID to document the change. Entities within the same store_entity() call will share the same change_id. This parameter can also be used to link multiple store_entity() calls.</p>"},{"location":"osw/#osw.core.OSW.StoreEntityParam.edit_comment","title":"<code>edit_comment = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Additional comment to explain the edit.</p>"},{"location":"osw/#osw.core.OSW.StoreEntityParam.entities","title":"<code>entities</code>  <code>instance-attribute</code>","text":"<p>The entities to store. Can be a single entity or a list of entities.</p>"},{"location":"osw/#osw.core.OSW.StoreEntityParam.namespace","title":"<code>namespace</code>  <code>instance-attribute</code>","text":"<p>The namespace of the entities. If not set, the namespace is derived from the entity.</p>"},{"location":"osw/#osw.core.OSW.StoreEntityParam.offline","title":"<code>offline = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>If set to True, the processed entities are not upload but only returned as WtPages. Can be used to create WtPage objects from entities without uploading them.</p>"},{"location":"osw/#osw.core.OSW.StoreEntityParam.overwrite","title":"<code>overwrite = 'keep existing'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>If no class specific overwrite setting is set, this setting is used.</p>"},{"location":"osw/#osw.core.OSW.StoreEntityParam.overwrite_per_class","title":"<code>overwrite_per_class = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A list of OverwriteClassParam objects. If a class specific overwrite setting is set, this setting is used.</p>"},{"location":"osw/#osw.core.OSW.StoreEntityParam.parallel","title":"<code>parallel = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>If set to True, the entities are stored in parallel.</p>"},{"location":"osw/#osw.core.OSW.StoreEntityParam.remove_empty","title":"<code>remove_empty = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>If true, remove key with an empty string value from the jsondata.</p>"},{"location":"osw/#osw.core.OSW.StoreEntityResult","title":"<code>StoreEntityResult</code>  <code>dataclass</code>","text":"<p>               Bases: <code>OswBaseModel</code></p> <p>Result of store_entity()</p> Source code in <code>src/osw/core.py</code> <pre><code>class StoreEntityResult(OswBaseModel):\n    \"\"\"Result of store_entity()\"\"\"\n\n    change_id: str\n    \"\"\"The ID of the change\"\"\"\n    pages: Dict[str, WtPage]\n    \"\"\"The pages that have been stored\"\"\"\n\n    class Config:\n        arbitrary_types_allowed = True\n</code></pre>"},{"location":"osw/#osw.core.OSW.StoreEntityResult.change_id","title":"<code>change_id</code>  <code>instance-attribute</code>","text":"<p>The ID of the change</p>"},{"location":"osw/#osw.core.OSW.StoreEntityResult.pages","title":"<code>pages</code>  <code>instance-attribute</code>","text":"<p>The pages that have been stored</p>"},{"location":"osw/#osw.core.OSW._ApplyOverwriteParam","title":"<code>_ApplyOverwriteParam</code>","text":"<p>               Bases: <code>OswBaseModel</code></p> Source code in <code>src/osw/core.py</code> <pre><code>class _ApplyOverwriteParam(OswBaseModel):\n    page: WtPage\n    entity: OswBaseModel  # actually model.Entity but this causes the \"type\" error\n    policy: Union[OSW.OverwriteClassParam, OVERWRITE_CLASS_OPTIONS]\n    namespace: Optional[str]\n    remove_empty: Optional[bool] = True\n    inplace: Optional[bool] = False\n    debug: Optional[bool] = False\n    offline: Optional[bool] = False\n\n    class Config:\n        arbitrary_types_allowed = True\n\n    @validator(\"entity\")\n    def validate_entity(cls, entity, values):\n        \"\"\"Make sure that the passed entity has the same uuid as the page\"\"\"\n        page: WtPage = values.get(\"page\")\n        if not page.exists:  # Guard clause\n            return entity\n        jsondata = page.get_slot_content(\"jsondata\")\n        if jsondata is None:  # Guard clause\n            title = title_from_full_title(page.title)\n            try:\n                uuid_from_title = get_uuid(title)\n            except ValueError:\n                print(\n                    f\"Error: UUID could not be determined from title: '{title}', \"\n                    f\"nor fromjsondata: {jsondata}\"\n                )\n                return entity\n            if str(uuid_from_title) != str(entity.uuid):\n                raise ValueError(\n                    f\"UUID mismatch: Page UUID: {uuid_from_title}, \"\n                    f\"Entity UUID: {entity.uuid}\"\n                )\n            return entity\n        page_uuid = str(jsondata.get(\"uuid\"))\n        entity_uuid = str(getattr(entity, \"uuid\", None))\n        if page_uuid != entity_uuid or page_uuid == str(None):\n            # Comparing string type UUIDs\n            raise ValueError(\n                f\"UUID mismatch: Page UUID: {page_uuid}, Entity UUID: {entity_uuid}\"\n            )\n        return entity\n\n    def __init__(self, **data):\n        super().__init__(**data)\n        if self.namespace is None:\n            self.namespace = get_namespace(self.entity)\n        if self.namespace is None:\n            raise ValueError(\"Namespace could not be determined.\")\n        if not isinstance(self.policy, OSW.OverwriteClassParam):\n            self.policy = OSW.OverwriteClassParam(\n                model=self.entity.__class__,\n                overwrite=self.policy,\n            )\n</code></pre>"},{"location":"osw/#osw.core.OSW._ApplyOverwriteParam.validate_entity","title":"<code>validate_entity(entity, values)</code>","text":"<p>Make sure that the passed entity has the same uuid as the page</p> Source code in <code>src/osw/core.py</code> <pre><code>@validator(\"entity\")\ndef validate_entity(cls, entity, values):\n    \"\"\"Make sure that the passed entity has the same uuid as the page\"\"\"\n    page: WtPage = values.get(\"page\")\n    if not page.exists:  # Guard clause\n        return entity\n    jsondata = page.get_slot_content(\"jsondata\")\n    if jsondata is None:  # Guard clause\n        title = title_from_full_title(page.title)\n        try:\n            uuid_from_title = get_uuid(title)\n        except ValueError:\n            print(\n                f\"Error: UUID could not be determined from title: '{title}', \"\n                f\"nor fromjsondata: {jsondata}\"\n            )\n            return entity\n        if str(uuid_from_title) != str(entity.uuid):\n            raise ValueError(\n                f\"UUID mismatch: Page UUID: {uuid_from_title}, \"\n                f\"Entity UUID: {entity.uuid}\"\n            )\n        return entity\n    page_uuid = str(jsondata.get(\"uuid\"))\n    entity_uuid = str(getattr(entity, \"uuid\", None))\n    if page_uuid != entity_uuid or page_uuid == str(None):\n        # Comparing string type UUIDs\n        raise ValueError(\n            f\"UUID mismatch: Page UUID: {page_uuid}, Entity UUID: {entity_uuid}\"\n        )\n    return entity\n</code></pre>"},{"location":"osw/#osw.core.OSW._FetchSchemaParam","title":"<code>_FetchSchemaParam</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Internal param for _fetch_schema()</p> <p>Attributes:</p> Name Type Description <code>schema_title</code> <code>Optional[str]</code> <p>the title (wiki page name) of the schema (default: Category:Item)</p> <code>root</code> <code>Optional[bool]</code> <p>marks the root iteration for a recursive fetch (internal param, default: True)</p> <code>mode</code> <code>Optional[str]</code> <p>append or replace (default) current schema, see FetchSchemaMode</p> Source code in <code>src/osw/core.py</code> <pre><code>class _FetchSchemaParam(BaseModel):\n    \"\"\"Internal param for _fetch_schema()\n\n    Attributes\n    ----------\n    schema_title:\n        the title (wiki page name) of the schema (default: Category:Item)\n    root:\n        marks the root iteration for a recursive fetch (internal param,\n        default: True)\n    mode:\n        append or replace (default) current schema, see FetchSchemaMode\n    \"\"\"\n\n    schema_title: Optional[str] = \"Category:Item\"\n    root: Optional[bool] = True\n    mode: Optional[str] = (\n        \"replace\"\n        # type 'FetchSchemaMode' requires: 'from __future__ import annotations'\n    )\n    legacy_generator: Optional[bool] = False\n    \"\"\"uses legacy command line for code generation if true\"\"\"\n</code></pre>"},{"location":"osw/#osw.core.OSW._FetchSchemaParam.legacy_generator","title":"<code>legacy_generator = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>uses legacy command line for code generation if true</p>"},{"location":"osw/#osw.core.OSW._fetch_schema","title":"<code>_fetch_schema(fetchSchemaParam=None)</code>","text":"<p>Loads the given schema from the OSW instance and autogenerates python datasclasses within osw.model.entity from it</p> <p>Parameters:</p> Name Type Description Default <code>fetchSchemaParam</code> <code>_FetchSchemaParam</code> <p>See FetchSchemaParam, by default None</p> <code>None</code> Source code in <code>src/osw/core.py</code> <pre><code>def _fetch_schema(self, fetchSchemaParam: _FetchSchemaParam = None) -&gt; None:\n    \"\"\"Loads the given schema from the OSW instance and autogenerates python\n    datasclasses within osw.model.entity from it\n\n    Parameters\n    ----------\n    fetchSchemaParam\n        See FetchSchemaParam, by default None\n    \"\"\"\n    site_cache_state = self.site.get_cache_enabled()\n    self.site.enable_cache()\n    if fetchSchemaParam is None:\n        fetchSchemaParam = OSW._FetchSchemaParam()\n    schema_title = fetchSchemaParam.schema_title\n    root = fetchSchemaParam.root\n    schema_name = schema_title.split(\":\")[-1]\n    page = self.site.get_page(WtSite.GetPageParam(titles=[schema_title])).pages[0]\n    if not page.exists:\n        print(f\"Error: Page {schema_title} does not exist\")\n        return\n    # not only in the JsonSchema namespace the schema is located in the main sot\n    # in all other namespaces, the json_schema slot is used\n    if schema_title.startswith(\"JsonSchema:\"):\n        schema_str = \"\"\n        if page.get_slot_content(\"main\"):\n            schema_str = json.dumps(page.get_slot_content(\"main\"))\n    else:\n        schema_str = \"\"\n        if page.get_slot_content(\"jsonschema\"):\n            schema_str = json.dumps(page.get_slot_content(\"jsonschema\"))\n    if (schema_str is None) or (schema_str == \"\"):\n        print(f\"Error: Schema {schema_title} does not exist\")\n        schema_str = \"{}\"  # empty schema to make reference work\n    schema = json.loads(\n        schema_str.replace(\"$ref\", \"dollarref\").replace(\n            # '$' is a special char for root object in jsonpath\n            '\"allOf\": [',\n            '\"allOf\": [{},',\n        )\n        # fix https://github.com/koxudaxi/datamodel-code-generator/issues/1910\n    )\n    print(f\"Fetch {schema_title}\")\n\n    jsonpath_expr = parse(\"$..dollarref\")\n    for match in jsonpath_expr.find(schema):\n        # value = \"https://\" + self.mw_site.host + match.value\n        if match.value.startswith(\"#\"):\n            continue  # skip self references\n        ref_schema_title = match.value.replace(\"/wiki/\", \"\").split(\"?\")[0]\n        ref_schema_name = ref_schema_title.split(\":\")[-1] + \".json\"\n        value = \"\"\n        for _i in range(0, schema_name.count(\"/\")):\n            value += \"../\"  # created relative path to top-level schema dir\n        value += ref_schema_name  # create a reference to a local file\n        # keep document-relative jsonpointer if present\n        if \"#/\" in match.value:\n            value += \"#/\" + match.value.split(\"#/\")[-1]\n        match.full_path.update_or_create(schema, value)\n        # print(f\"replace {match.value} with {value}\")\n        if (\n            ref_schema_title != schema_title\n        ):  # prevent recursion in case of self references\n            self._fetch_schema(\n                OSW._FetchSchemaParam(schema_title=ref_schema_title, root=False)\n            )  # resolve references recursive\n\n    model_dir_path = os.path.join(\n        os.path.dirname(os.path.abspath(__file__)), \"model\"\n    )  # src/model\n    schema_path = os.path.join(model_dir_path, schema_name + \".json\")\n    os.makedirs(os.path.dirname(schema_path), exist_ok=True)\n    with open(schema_path, \"w\", encoding=\"utf-8\") as f:\n        schema_str = json.dumps(schema, ensure_ascii=False, indent=4).replace(\n            \"dollarref\", \"$ref\"\n        )\n        # print(schema_str)\n        f.write(schema_str)\n\n    # result_model_path = schema_path.replace(\".json\", \".py\")\n    result_model_path = os.path.join(model_dir_path, \"entity.py\")\n    temp_model_path = os.path.join(model_dir_path, \"temp.py\")\n    if root:\n        if fetchSchemaParam.legacy_generator:\n            exec_name = \"datamodel-codegen\"\n            # default: assume datamodel-codegen is in PATH\n            exec_path = exec_name\n            if platform.system() == \"Windows\":\n                exec_name += \".exe\"\n                exec_path = os.path.join(\n                    os.path.dirname(os.path.abspath(sys.executable)), exec_name\n                )\n                if not os.path.isfile(exec_path):\n                    exec_path = os.path.join(\n                        os.path.dirname(os.path.abspath(sys.executable)),\n                        \"Scripts\",\n                        exec_name,\n                    )\n                if not os.path.isfile(exec_path):\n                    print(\"Error: datamodel-codegen not found\")\n                    return\n            os.system(\n                f\"{exec_path}  \\\n                --input {schema_path} \\\n                --input-file-type jsonschema \\\n                --output {temp_model_path} \\\n                --base-class osw.model.static.OswBaseModel \\\n                --use-default \\\n                --use-unique-items-as-set \\\n                --enum-field-as-literal all \\\n                --use-title-as-name \\\n                --use-schema-description \\\n                --use-field-description \\\n                --encoding utf-8 \\\n                --use-double-quotes \\\n                --collapse-root-models \\\n                --reuse-model \\\n            \"\n            )\n        else:\n            datamodel_code_generator.generate(\n                input_=pathlib.Path(schema_path),\n                input_file_type=\"jsonschema\",\n                output=pathlib.Path(temp_model_path),\n                base_class=\"osw.model.static.OswBaseModel\",\n                # use_default=True,\n                apply_default_values_for_required_fields=True,\n                use_unique_items_as_set=True,\n                enum_field_as_literal=datamodel_code_generator.LiteralType.All,\n                use_title_as_name=True,\n                use_schema_description=True,\n                use_field_description=True,\n                encoding=\"utf-8\",\n                use_double_quotes=True,\n                collapse_root_models=True,\n                reuse_model=True,\n            )\n\n        # see https://koxudaxi.github.io/datamodel-code-generator/\n        # --base-class OswBaseModel: use a custom base class\n        # --custom-template-dir src/model/template_data/\n        # --extra-template-data src/model/template_data/extra.json\n        # --use-default: Use default value even if a field is required\n        # --use-unique-items-as-set: define field type as `set` when the field\n        #  attribute has`uniqueItems`\n        # --enum-field-as-literal all: prevent 'value is not a valid enumeration\n        #  member' errors after schema reloading\n        # --use-schema-description: Use schema description to populate class\n        #  docstring\n        # --use-field-description: Use schema description to populate field\n        #  docstring\n        # --use-title-as-name: use titles as class names of models, e.g. for the\n        #  footer templates\n        # --collapse-root-models: Models generated with a root-type field will be\n        #  merged\n        # into the models using that root-type model, e.g. for Entity.statements\n        # --reuse-model: Re-use models on the field when a module has the model\n        #  with the same content\n\n        content = \"\"\n        with open(temp_model_path, \"r\", encoding=\"utf-8\") as f:\n            content = f.read()\n        os.remove(temp_model_path)\n\n        content = re.sub(\n            r\"(UUID = Field\\(...)\",\n            r\"UUID = Field(default_factory=uuid4\",\n            content,\n        )  # enable default value for uuid\n\n        # we are now using pydantic.v1\n        # pydantic imports lead to uninitialized fields (FieldInfo still present)\n        content = re.sub(\n            r\"(from pydantic import)\", \"from pydantic.v1 import\", content\n        )\n\n        # remove field param unique_items\n        # --use-unique-items-as-set still keeps unique_items=True as Field param\n        # which was removed, see https://github.com/pydantic/pydantic-core/issues/296\n        # --output-model-type pydantic_v2.BaseModel fixes that but generated models\n        # are not v1 compatible mainly by using update_model()\n        content = re.sub(r\"(,?\\s*unique_items=True\\s*)\", \"\", content)\n\n        if fetchSchemaParam.mode == \"replace\":\n            header = (\n                \"from uuid import uuid4\\n\"\n                \"from typing import Type, TypeVar\\n\"\n                \"from osw.model.static import OswBaseModel, Ontology\\n\"\n                # \"from osw.model.static import *\\n\"\n                \"\\n\"\n            )\n\n            content = re.sub(\n                pattern=r\"(class\\s*\\S*\\s*\\(\\s*OswBaseModel\\s*\\)\\s*:.*\\n)\",\n                repl=header + r\"\\n\\n\\n\\1\",\n                string=content,\n                count=1,\n            )  # add header before first class declaration\n\n            with open(result_model_path, \"w\", encoding=\"utf-8\") as f:\n                f.write(content)\n\n        if fetchSchemaParam.mode == \"append\":\n            org_content = \"\"\n            with open(result_model_path, \"r\", encoding=\"utf-8\") as f:\n                org_content = f.read()\n\n            pattern = re.compile(\n                r\"class\\s*([\\S]*)\\s*\\(\\s*\\S*\\s*\\)\\s*:.*\\n\"\n            )  # match class definition [\\s\\S]*(?:[^\\S\\n]*\\n){2,}\n            for cls in re.findall(pattern, org_content):\n                print(cls)\n                content = re.sub(\n                    r\"(class\\s*\"\n                    + cls\n                    + r\"\\s*\\(\\s*\\S*\\s*\\)\\s*:.*\\n[\\s\\S]*?(?:[^\\S\\n]*\\n){3,})\",\n                    \"\",\n                    content,\n                    count=1,\n                )  # replace duplicated classes\n\n            content = re.sub(\n                pattern=r\"(from __future__ import annotations)\",\n                repl=\"\",\n                string=content,\n                count=1,\n            )  # remove import statement\n            # print(content)\n            with open(result_model_path, \"a\", encoding=\"utf-8\") as f:\n                f.write(content)\n\n        importlib.reload(model)  # reload the updated module\n        if not site_cache_state:\n            self.site.disable_cache()  # restore original state\n</code></pre>"},{"location":"osw/#osw.core.OSW.check_dependencies","title":"<code>check_dependencies(dependencies)</code>  <code>staticmethod</code>","text":"<p>Check if the dependencies are installed in the osw.model.entity module.</p> <p>Parameters:</p> Name Type Description Default <code>dependencies</code> <code>Dict[str, str]</code> <p>A dictionary with the keys being the names of the dependencies and the values being the full page name (IRI) of the dependencies.</p> required Source code in <code>src/osw/core.py</code> <pre><code>@staticmethod\ndef check_dependencies(dependencies: Dict[str, str]) -&gt; List[str]:\n    \"\"\"Check if the dependencies are installed in the osw.model.entity module.\n\n    Parameters\n    ----------\n    dependencies\n        A dictionary with the keys being the names of the dependencies and the\n        values being the full page name (IRI) of the dependencies.\n    \"\"\"\n    return [dep for dep in dependencies if not hasattr(model, dep)]\n</code></pre>"},{"location":"osw/#osw.core.OSW.close_connection","title":"<code>close_connection()</code>","text":"<p>Close the connection to the OSL instance.</p> Source code in <code>src/osw/core.py</code> <pre><code>def close_connection(self):\n    \"\"\"Close the connection to the OSL instance.\"\"\"\n    self.mw_site.connection.close()\n</code></pre>"},{"location":"osw/#osw.core.OSW.delete_entity","title":"<code>delete_entity(entity, comment=None)</code>","text":"<p>Deletes the given entity/entities from the OSW instance.</p> Source code in <code>src/osw/core.py</code> <pre><code>def delete_entity(\n    self,\n    entity: Union[OswBaseModel, List[OswBaseModel], DeleteEntityParam],\n    comment: str = None,\n):\n    \"\"\"Deletes the given entity/entities from the OSW instance.\"\"\"\n    if not isinstance(entity, OSW.DeleteEntityParam):\n        entity = OSW.DeleteEntityParam(entities=entity)\n    if comment is not None:\n        entity.comment = comment\n\n    def delete_entity_(entity_, comment_: str = None):\n        \"\"\"Deletes the given entity from the OSW instance.\n\n        Parameters\n        ----------\n        entity_:\n            The dataclass instance to delete\n        comment_:\n            Command for the change log, by default None\n        \"\"\"\n        title_ = None\n        namespace_ = None\n        if hasattr(entity_, \"meta\"):\n            if entity_.meta and entity_.meta.wiki_page:\n                if entity_.meta.wiki_page.title:\n                    title_ = entity_.meta.wiki_page.title\n                if entity_.meta.wiki_page.namespace:\n                    namespace_ = entity_.meta.wiki_page.namespace\n        if namespace_ is None:\n            namespace_ = get_namespace(entity_)\n        if title_ is None:\n            title_ = OSW.get_osw_id(entity_.uuid)\n        if namespace_ is None or title_ is None:\n            print(\"Error: Unsupported entity type\")\n            return\n        entity_title = namespace_ + \":\" + title_\n        page = self.site.get_page(WtSite.GetPageParam(titles=[entity_title])).pages[\n            0\n        ]\n\n        if page.exists:\n            page.delete(comment_)\n            print(\"Entity deleted: \" + page.get_url())\n        else:\n            print(f\"Entity '{entity_title}' does not exist!\")\n\n    if entity.parallel:\n        _ = parallelize(\n            delete_entity_,\n            entity.entities,\n            flush_at_end=entity.debug,\n            comment_=entity.comment,\n        )\n    else:\n        _ = [delete_entity_(e, entity.comment) for e in entity.entities]\n</code></pre>"},{"location":"osw/#osw.core.OSW.ensure_dependencies","title":"<code>ensure_dependencies(dependencies)</code>","text":"<p>Ensure that the dependencies are installed in the osw.model.entity module.</p> <p>Parameters:</p> Name Type Description Default <code>dependencies</code> <code>Dict[str, str]</code> <p>A dictionary with the keys being the names of the dependencies and the values being the full page name (IRI) of the dependencies.</p> required Source code in <code>src/osw/core.py</code> <pre><code>def ensure_dependencies(self, dependencies: Dict[str, str]):\n    \"\"\"Ensure that the dependencies are installed in the osw.model.entity module.\n\n    Parameters\n    ----------\n    dependencies\n        A dictionary with the keys being the names of the dependencies and the\n        values being the full page name (IRI) of the dependencies.\n    \"\"\"\n    if self.check_dependencies(dependencies):\n        self.install_dependencies(dependencies)\n</code></pre>"},{"location":"osw/#osw.core.OSW.export_jsonld","title":"<code>export_jsonld(params)</code>","text":"<p>Exports the given entity/entities as JSON-LD.</p> Source code in <code>src/osw/core.py</code> <pre><code>def export_jsonld(self, params: ExportJsonLdParams) -&gt; ExportJsonLdResult:\n    \"\"\"Exports the given entity/entities as JSON-LD.\"\"\"\n\n    if params.resolve_context:\n        jsonld.set_document_loader(\n            self.site.get_jsonld_context_loader(params.context_loader_config)\n        )\n\n    documents = []\n    graph_document = {\"@graph\": []}\n    graph = None\n    if params.build_rdf_graph:\n        graph = rdflib.Graph()\n        prefixes = self.site.get_prefix_dict()\n        for prefix in prefixes:\n            graph.bind(prefix, prefixes[prefix])\n\n    for e in params.entities:\n        data = json.loads(e.json(exclude_none=True, indent=4, ensure_ascii=False))\n\n        data[\"@context\"] = []\n        if params.id_keys is not None:\n            # append \"@id\" mappings to the context in an additional object\n            id_mapping = {}\n            for k in params.id_keys:\n                id_mapping[k] = \"@id\"\n            data[\"@context\"].append(id_mapping)\n        if params.context is None:\n            for t in e.type:\n                data[\"@context\"].append(\"/wiki/\" + t)\n            if params.context is not None:\n                data[\"@context\"].append(params.context)\n        else:\n            data[\"@context\"].append(self.site.get_jsonld_context_prefixes())\n            if isinstance(params.context, list):\n                data[\"@context\"].extend(params.context)\n            else:\n                data[\"@context\"].append(params.context)\n        if params.additional_context is not None:\n            if data[\"@context\"] is None:\n                data[\"@context\"] = []\n            elif not isinstance(data[\"@context\"], list):\n                data[\"@context\"] = [data[\"@context\"]]\n            data[\"@context\"].append(params.additional_context)\n\n        # if none of the id_keys is found, use the full title\n        if not any(k in data for k in params.id_keys):\n            data[\"@id\"] = get_full_title(e)\n\n        if params.resolve_context:\n            graph_document[\"@graph\"].append(jsonld.expand(data))\n            if params.mode == \"expand\":\n                data = jsonld.expand(data)\n                if isinstance(data, list) and len(data) &gt; 0:\n                    data = data[0]\n            elif params.mode == \"flatten\":\n                data = jsonld.flatten(data)\n            elif params.mode == \"compact\":\n                # data = jsonld.expand(data)\n                # if isinstance(data, list): data = data[0]\n                data = jsonld.compact(\n                    data,\n                    data[\"@context\"] if params.context is None else params.context,\n                )\n            elif params.mode == \"frame\":\n                data = jsonld.frame(\n                    data,\n                    (\n                        {\"@context\": data[\"@context\"]}\n                        if params.frame is None\n                        else params.frame\n                    ),\n                )\n\n            if params.build_rdf_graph:\n                graph.parse(data=json.dumps(data), format=\"json-ld\")\n\n        documents.append(data)\n\n    result = OSW.ExportJsonLdResult(\n        documents=documents, graph_document=graph_document, graph=graph\n    )\n    return result\n</code></pre>"},{"location":"osw/#osw.core.OSW.fetch_schema","title":"<code>fetch_schema(fetchSchemaParam=None)</code>","text":"<p>Loads the given schemas from the OSW instance and auto-generates python datasclasses within osw.model.entity from it</p> <p>Parameters:</p> Name Type Description Default <code>fetchSchemaParam</code> <code>FetchSchemaParam</code> <p>See FetchSchemaParam, by default None</p> <code>None</code> Source code in <code>src/osw/core.py</code> <pre><code>def fetch_schema(self, fetchSchemaParam: FetchSchemaParam = None) -&gt; None:\n    \"\"\"Loads the given schemas from the OSW instance and auto-generates python\n    datasclasses within osw.model.entity from it\n\n    Parameters\n    ----------\n    fetchSchemaParam\n        See FetchSchemaParam, by default None\n    \"\"\"\n    if not isinstance(fetchSchemaParam.schema_title, list):\n        fetchSchemaParam.schema_title = [fetchSchemaParam.schema_title]\n    first = True\n    for schema_title in fetchSchemaParam.schema_title:\n        mode = fetchSchemaParam.mode\n        if not first:  # 'replace' makes only sense for the first schema\n            mode = \"append\"\n        self._fetch_schema(\n            OSW._FetchSchemaParam(\n                schema_title=schema_title,\n                mode=mode,\n                legacy_generator=fetchSchemaParam.legacy_generator,\n            )\n        )\n        first = False\n</code></pre>"},{"location":"osw/#osw.core.OSW.get_osw_id","title":"<code>get_osw_id(uuid)</code>  <code>staticmethod</code>","text":"<p>Generates a OSW-ID based on the given uuid by prefixing \"OSW\" and removing all '-' from the uuid-string</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>Union[str, UUID]</code> <p>uuid object, e.g. UUID(\"2ea5b605-c91f-4e5a-9559-3dff79fdd4a5\")</p> required <p>Returns:</p> Type Description <code>    OSW-ID string, e.g. OSW2ea5b605c91f4e5a95593dff79fdd4a5</code> Source code in <code>src/osw/core.py</code> <pre><code>@staticmethod\ndef get_osw_id(uuid: Union[str, UUID]) -&gt; str:\n    \"\"\"Generates a OSW-ID based on the given uuid by prefixing \"OSW\" and removing\n    all '-' from the uuid-string\n\n    Parameters\n    ----------\n    uuid\n        uuid object, e.g. UUID(\"2ea5b605-c91f-4e5a-9559-3dff79fdd4a5\")\n\n    Returns\n    -------\n        OSW-ID string, e.g. OSW2ea5b605c91f4e5a95593dff79fdd4a5\n    \"\"\"\n    return \"OSW\" + str(uuid).replace(\"-\", \"\")\n</code></pre>"},{"location":"osw/#osw.core.OSW.get_uuid","title":"<code>get_uuid(osw_id)</code>  <code>staticmethod</code>","text":"<p>Returns the uuid for a given OSW-ID</p> <p>Parameters:</p> Name Type Description Default <code>osw_id</code> <code>str</code> <p>OSW-ID string, e.g. OSW2ea5b605c91f4e5a95593dff79fdd4a5</p> required <p>Returns:</p> Type Description <code>    uuid object, e.g. UUID(\"2ea5b605-c91f-4e5a-9559-3dff79fdd4a5\")</code> Source code in <code>src/osw/core.py</code> <pre><code>@staticmethod\ndef get_uuid(osw_id: str) -&gt; UUID:\n    \"\"\"Returns the uuid for a given OSW-ID\n\n    Parameters\n    ----------\n    osw_id\n        OSW-ID string, e.g. OSW2ea5b605c91f4e5a95593dff79fdd4a5\n\n    Returns\n    -------\n        uuid object, e.g. UUID(\"2ea5b605-c91f-4e5a-9559-3dff79fdd4a5\")\n    \"\"\"\n    return UUID(osw_id.replace(\"OSW\", \"\"))\n</code></pre>"},{"location":"osw/#osw.core.OSW.install_dependencies","title":"<code>install_dependencies(dependencies=None, mode='append', policy='force')</code>","text":"<p>Installs data models, listed in the dependencies, in the osw.model.entity module.</p> <p>Parameters:</p> Name Type Description Default <code>dependencies</code> <code>Dict[str, str]</code> <p>A dictionary with the keys being the names of the dependencies and the values being the full page name (IRI) of the dependencies.</p> <code>None</code> <code>mode</code> <code>str</code> <p>The mode to use when loading the dependencies. Default is 'append', which will keep existing data models and only load the missing ones. The mode 'replace' will replace all existing data models with the new ones.</p> <code>'append'</code> <code>policy</code> <code>str</code> <p>The policy to use when loading the dependencies. Default is 'force', which will always load the dependencies. If policy is 'if-missing', dependencies will only be loaded if they are not already installed. This may lead to outdated dependencies, if the dependencies have been updated on the server. If policy is 'if-outdated', dependencies will only be loaded if they were updated on the server. (not implemented yet)</p> <code>'force'</code> Source code in <code>src/osw/core.py</code> <pre><code>def install_dependencies(\n    self,\n    dependencies: Dict[str, str] = None,\n    mode: str = \"append\",\n    policy: str = \"force\",\n):\n    \"\"\"Installs data models, listed in the dependencies, in the osw.model.entity\n    module.\n\n    Parameters\n    ----------\n    dependencies\n        A dictionary with the keys being the names of the dependencies and the\n        values being the full page name (IRI) of the dependencies.\n    mode\n        The mode to use when loading the dependencies. Default is 'append',\n        which will keep existing data models and only load the missing ones. The\n        mode 'replace' will replace all existing data models with the new ones.\n    policy\n        The policy to use when loading the dependencies. Default is 'force',\n        which will always load the dependencies. If policy is 'if-missing',\n        dependencies will only be loaded if they are not already installed.\n        This may lead to outdated dependencies, if the dependencies have been\n        updated on the server. If policy is 'if-outdated', dependencies will only\n        be loaded if they were updated on the server. (not implemented yet)\n    \"\"\"\n    if dependencies is None:\n        if default_params.dependencies is None:\n            raise ValueError(\n                \"No 'dependencies' parameter was passed to \"\n                \"install_dependencies() and \"\n                \"osw.defaults.params.dependencies was not set!\"\n            )\n        dependencies = default_params.dependencies\n    schema_fpts = []\n    for k, v in dependencies.items():\n        if policy != \"if-missing\" or not hasattr(model, k):\n            schema_fpts.append(v)\n        if policy == \"if-outdated\":\n            raise NotImplementedError(\n                \"The policy 'if-outdated' is not implemented yet.\"\n            )\n    schema_fpts = list(set(schema_fpts))\n    for schema_fpt in schema_fpts:\n        if not schema_fpt.count(\":\") == 1:\n            raise ValueError(\n                f\"Full page title '{schema_fpt}' does not have the correct format. \"\n                \"It should be 'Namespace:Name'.\"\n            )\n    self.fetch_schema(OSW.FetchSchemaParam(schema_title=schema_fpts, mode=mode))\n</code></pre>"},{"location":"osw/#osw.core.OSW.load_entity","title":"<code>load_entity(entity_title)</code>","text":"<pre><code>load_entity(entity_title: str) -&gt; model.Entity\n</code></pre><pre><code>load_entity(entity_title: List[str]) -&gt; List[model.Entity]\n</code></pre><pre><code>load_entity(entity_title: LoadEntityParam) -&gt; LoadEntityResult\n</code></pre> <p>Loads the entity with the given wiki page name from the OSW instance. Creates an instance of the class specified by the \"type\" attribute, default model.Entity. An instance of model.Entity can be cast to any subclass with .cast(model.) . <p>Parameters:</p> Name Type Description Default <code>entity_title</code> <code>Union[str, List[str], LoadEntityParam]</code> <p>the wiki page name</p> required <p>Returns:</p> Type Description <code>    the dataclass instance if only a single title is given</code> <p>a list of dataclass instances if a list of titles is given a LoadEntityResult instance if a LoadEntityParam is given</p> Source code in <code>src/osw/core.py</code> <pre><code>def load_entity(\n    self, entity_title: Union[str, List[str], LoadEntityParam]\n) -&gt; Union[model.Entity, List[model.Entity], LoadEntityResult]:\n    \"\"\"Loads the entity with the given wiki page name from the OSW instance.\n    Creates an instance of the class specified by the \"type\" attribute, default\n    model.Entity. An instance of model.Entity can be cast to any subclass with\n    .cast(model.&lt;class&gt;) .\n\n    Parameters\n    ----------\n    entity_title\n        the wiki page name\n\n    Returns\n    -------\n        the dataclass instance if only a single title is given\n        a list of dataclass instances if a list of titles is given\n        a LoadEntityResult instance if a LoadEntityParam is given\n    \"\"\"\n    if isinstance(entity_title, str):\n        param = OSW.LoadEntityParam(titles=[entity_title])\n    elif isinstance(entity_title, list):\n        param = OSW.LoadEntityParam(titles=entity_title)\n    else:\n        param = entity_title\n\n    if param.model_to_use:\n        print(f\"Using schema {param.model_to_use.__name__} to create entity\")\n\n    # store original cache state\n    cache_state = self.site.get_cache_enabled()\n    if param.disable_cache:\n        self.site.disable_cache()\n    if not cache_state and param.disable_cache:\n        # enable cache to speed up loading\n        self.site.enable_cache()\n\n    entities = []\n    pages = self.site.get_page(WtSite.GetPageParam(titles=param.titles)).pages\n    for page in pages:\n        entity = None\n        schemas = []\n        schemas_fetched = True\n        jsondata = page.get_slot_content(\"jsondata\")\n        if param.remove_empty:\n            remove_empty(jsondata)\n        if jsondata:\n            for category in jsondata[\"type\"]:\n                schema = (\n                    self.site.get_page(WtSite.GetPageParam(titles=[category]))\n                    .pages[0]\n                    .get_slot_content(\"jsonschema\")\n                )\n                schemas.append(schema)\n                # generate model if not already exists\n                cls_name: str = schema[\"title\"]\n                # If a schema_to_use is provided, we do not need to check if the\n                #  model exists\n                if not param.model_to_use:\n                    if not hasattr(model, cls_name):\n                        if param.autofetch_schema:\n                            self.fetch_schema(\n                                OSW.FetchSchemaParam(\n                                    schema_title=category, mode=\"append\"\n                                )\n                            )\n                    if not hasattr(model, cls_name):\n                        schemas_fetched = False\n                        print(\n                            f\"Error: Model {cls_name} not found. Schema {category} \"\n                            f\"needs to be fetched first.\"\n                        )\n        if not schemas_fetched:\n            continue\n\n        if param.model_to_use:\n            entity: model.OswBaseModel = param.model_to_use(**jsondata)\n\n        elif len(schemas) == 0:\n            print(\"Error: no schema defined\")\n\n        elif len(schemas) == 1:\n            cls: Type[model.Entity] = getattr(model, schemas[0][\"title\"])\n            entity: model.Entity = cls(**jsondata)\n\n        else:\n            bases = []\n            for schema in schemas:\n                bases.append(getattr(model, schema[\"title\"]))\n            cls = create_model(\"Test\", __base__=tuple(bases))\n            entity: model.Entity = cls(**jsondata)\n\n        if entity is not None:\n            # make sure we do not override existing metadata\n            if not hasattr(entity, \"meta\") or entity.meta is None:\n                entity.meta = model.Meta()\n            if (\n                not hasattr(entity.meta, \"wiki_page\")\n                or entity.meta.wiki_page is None\n            ):\n                entity.meta.wiki_page = model.WikiPage()\n            entity.meta.wiki_page.namespace = namespace_from_full_title(page.title)\n            entity.meta.wiki_page.title = title_from_full_title(page.title)\n\n        entities.append(entity)\n    # restore original cache state\n    if cache_state:\n        self.site.enable_cache()\n    else:\n        self.site.disable_cache()\n\n    if isinstance(entity_title, str):  # single title\n        if len(entities) &gt;= 1:\n            return entities[0]\n        else:\n            return None\n    if isinstance(entity_title, list):  # list of titles\n        return entities\n    if isinstance(entity_title, OSW.LoadEntityParam):  # LoadEntityParam\n        return OSW.LoadEntityResult(entities=entities)\n</code></pre>"},{"location":"osw/#osw.core.OSW.register_schema","title":"<code>register_schema(schema_registration)</code>","text":"<p>Registers a new or updated schema in OSW by creating the corresponding category page.</p> <p>Parameters:</p> Name Type Description Default <code>schema_registration</code> <code>SchemaRegistration</code> <p>see SchemaRegistration</p> required Source code in <code>src/osw/core.py</code> <pre><code>def register_schema(self, schema_registration: SchemaRegistration):\n    \"\"\"Registers a new or updated schema in OSW by creating the corresponding\n    category page.\n\n    Parameters\n    ----------\n    schema_registration\n        see SchemaRegistration\n    \"\"\"\n    entity = schema_registration.model_cls\n\n    jsondata = {}\n    jsondata[\"uuid\"] = schema_registration.schema_uuid\n    jsondata[\"label\"] = {\"text\": schema_registration.schema_name, \"lang\": \"en\"}\n    jsondata[\"subclass_of\"] = schema_registration.schema_bases\n\n    if issubclass(entity, BaseModel):\n        entity_title = \"Category:\" + OSW.get_osw_id(schema_registration.schema_uuid)\n\n        page = WtPage(wtSite=self.site, title=entity_title)\n        if page.exists:\n            page = self.site.get_page(\n                WtSite.GetPageParam(titles=[entity_title])\n            ).pages[0]\n\n        page.set_slot_content(\"jsondata\", jsondata)\n\n        schema = json.loads(\n            entity.schema_json(indent=4).replace(\"$ref\", \"dollarref\")\n        )\n\n        jsonpath_expr = parse(\"$..allOf\")\n        # Replace local definitions (#/definitions/...) with embedded definitions\n        #  to prevent resolve errors in json-editor\n        for match in jsonpath_expr.find(schema):\n            result_array = []\n            for subschema in match.value:\n                # pprint(subschema)\n                value = subschema[\"dollarref\"]\n                if value.startswith(\"#\"):\n                    definition_jsonpath_expr = parse(\n                        value.replace(\"#\", \"$\").replace(\"/\", \".\")\n                    )\n                    for def_match in definition_jsonpath_expr.find(schema):\n                        # pprint(def_match.value)\n                        result_array.append(def_match.value)\n                else:\n                    result_array.append(subschema)\n            match.full_path.update_or_create(schema, result_array)\n        if \"definitions\" in schema:\n            del schema[\"definitions\"]\n\n        if \"allOf\" not in schema:\n            schema[\"allOf\"] = []\n        for base in schema_registration.schema_bases:\n            schema[\"allOf\"].append(\n                {\"$ref\": f\"/wiki/{base}?action=raw&amp;slot=jsonschema\"}\n            )\n\n        page.set_slot_content(\"jsonschema\", schema)\n    else:\n        print(\"Error: Unsupported entity type\")\n        return\n\n    page.edit()\n    print(\"Entity stored at \" + page.get_url())\n</code></pre>"},{"location":"osw/#osw.core.OSW.sort_list_of_entities_by_class","title":"<code>sort_list_of_entities_by_class(entities, exclude_typeless=True, raise_error=False)</code>  <code>staticmethod</code>","text":"<p>Sorts a list of entities by class name and type.</p> <p>Parameters:</p> Name Type Description Default <code>entities</code> <code>List[OswBaseModel]</code> <p>List of entities to be sorted</p> required <code>exclude_typeless</code> <code>bool</code> <p>Exclude entities, which are instances of a class that does not define a field 'type'</p> <code>True</code> <code>raise_error</code> <code>bool</code> <p>Raise an error if an entity can not be processed because it is an instance of class that does not define a field 'type'</p> <code>False</code> Source code in <code>src/osw/core.py</code> <pre><code>@staticmethod\ndef sort_list_of_entities_by_class(\n    entities: List[OswBaseModel],\n    exclude_typeless: bool = True,\n    raise_error: bool = False,\n) -&gt; SortEntitiesResult:\n    \"\"\"Sorts a list of entities by class name and type.\n\n    Parameters\n    ----------\n    entities:\n        List of entities to be sorted\n    exclude_typeless:\n        Exclude entities, which are instances of a class that does not\n        define a field 'type'\n    raise_error:\n        Raise an error if an entity can not be processed because it is an\n        instance of class that does not define a field 'type'\n    \"\"\"\n    by_name = {}\n    by_type = {}\n    for entity in entities:\n        # Get class name\n        name = entity.__class__.__name__\n        # See if the class has a type field\n        if \"type\" not in entity.__class__.__fields__:\n            if raise_error:\n                raise AttributeError(\n                    f\"Instance '{entity}' of class '{name}' can not be processed \"\n                    f\"as the class does not define a field 'type'.\"\n                )\n            if exclude_typeless:\n                warn(\n                    f\"Skipping instance '{entity}' of class '{name}' as the class \"\n                    f\"does not define a field 'type'.\"\n                )\n                # Excludes the respective entity from the list which will be\n                #  processed further:\n                continue\n            model_type = None\n        else:\n            # Get class type if available\n            model_type = entity.__class__.__fields__[\"type\"].get_default()[0]\n        # Add entity to by_name\n        if name not in by_name:\n            by_name[name] = []\n        by_name[name].append(entity)\n        # Add entity to by_type\n        if model_type not in by_type:\n            by_type[model_type] = []\n        by_type[model_type].append(entity)\n\n    return OSW.SortEntitiesResult(by_name=by_name, by_type=by_type)\n</code></pre>"},{"location":"osw/#osw.core.OSW.store_entity","title":"<code>store_entity(param)</code>","text":"<p>stores the given dataclass instance as OSW page by calling BaseModel.json()</p> <p>Parameters:</p> Name Type Description Default <code>param</code> <code>Union[StoreEntityParam, OswBaseModel, List[OswBaseModel]]</code> <p>StoreEntityParam, the dataclass instance or a list of instances</p> required Source code in <code>src/osw/core.py</code> <pre><code>def store_entity(\n    self, param: Union[StoreEntityParam, OswBaseModel, List[OswBaseModel]]\n) -&gt; StoreEntityResult:\n    \"\"\"stores the given dataclass instance as OSW page by calling BaseModel.json()\n\n    Parameters\n    ----------\n    param:\n        StoreEntityParam, the dataclass instance or a list of instances\n    \"\"\"\n    if isinstance(param, model.Entity):\n        param = OSW.StoreEntityParam(entities=[param])\n    if isinstance(param, list):\n        param = OSW.StoreEntityParam(entities=param)\n    if not isinstance(param.entities, list):\n        param.entities = [param.entities]\n\n    param: OSW.StoreEntityParam = param\n\n    max_index = len(param.entities)\n    created_pages = {}\n\n    meta_category_templates = {}\n    if param.namespace == \"Category\":\n        meta_category_titles = param.meta_category_title\n        if not isinstance(meta_category_titles, list):\n            meta_category_titles = [meta_category_titles]\n        meta_category_template_strs = {}\n        # We have to do this iteratively to support meta categories inheritance\n        while meta_category_titles is not None and len(meta_category_titles) &gt; 0:\n            meta_categories = self.site.get_page(\n                WtSite.GetPageParam(titles=meta_category_titles)\n            ).pages\n            for meta_category in meta_categories:\n                meta_category_template_strs[meta_category.title] = (\n                    meta_category.get_slot_content(\"schema_template\")\n                )\n\n            meta_category_titles = meta_category.get_slot_content(\"jsondata\").get(\n                \"subclass_of\"\n            )\n\n        for title in meta_category_template_strs.keys():\n            meta_category_template_str = meta_category_template_strs[title]\n            if meta_category_template_str:\n                meta_category_templates[title] = compile_handlebars_template(\n                    meta_category_template_str\n                )\n        # inverse order to have the most generic template first\n        meta_category_templates = dict(reversed(meta_category_templates.items()))\n\n    def store_entity_(\n        entity_: model.Entity,\n        namespace_: str = None,\n        index: int = None,\n        overwrite_class_param: OSW.OverwriteClassParam = None,\n    ) -&gt; None:\n        title_ = get_title(entity_)\n        if namespace_ is None:\n            namespace_ = get_namespace(entity_)\n        if namespace_ is None or title_ is None:\n            print(\"Error: Unsupported entity type\")\n            return\n        if overwrite_class_param is None:\n            raise TypeError(\"'overwrite_class_param' must not be None!\")\n        entity_title = namespace_ + \":\" + title_\n        page = self._apply_overwrite_policy(\n            OSW._ApplyOverwriteParam(\n                page=WtPage(\n                    wtSite=self.site, title=entity_title, do_init=not param.offline\n                ),\n                entity=entity_,\n                namespace=namespace_,\n                policy=overwrite_class_param,\n                remove_empty=param.remove_empty,\n                debug=param.debug,\n                offline=param.offline,\n            )\n        )\n        if len(meta_category_templates.keys()) &gt; 0:\n            generated_schemas = {}\n            try:\n                jsondata = page.get_slot_content(\"jsondata\")\n                if param.remove_empty:\n                    remove_empty(jsondata)\n\n                for key in meta_category_templates:\n                    meta_category_template = meta_category_templates[key]\n                    schema_str = eval_compiled_handlebars_template(\n                        meta_category_template,\n                        escape_json_strings(jsondata),\n                        {\n                            \"_page_title\": entity_title,  # Legacy\n                            \"_current_subject_\": entity_title,\n                        },\n                    )\n                    generated_schemas[key] = json.loads(schema_str)\n            except Exception as e:\n                print(f\"Schema generation from template failed for {entity_}: {e}\")\n\n            mode = AggregateGeneratedSchemasParamMode.ROOT_LEVEL\n            # Put generated schema in definitions section,\n            #  currently only enabled for Characteristics\n            if hasattr(model, \"CharacteristicType\") and isinstance(\n                entity_, model.CharacteristicType\n            ):\n                mode = AggregateGeneratedSchemasParamMode.DEFINITIONS_SECTION\n\n            new_schema = aggregate_generated_schemas(\n                AggregateGeneratedSchemasParam(\n                    schema=page.get_slot_content(\"jsonschema\"),\n                    generated_schemas=generated_schemas,\n                    mode=mode,\n                )\n            ).aggregated_schema\n            page.set_slot_content(\"jsonschema\", new_schema)\n        if param.offline is False:\n            page.edit(\n                param.edit_comment, bot_edit=param.bot_edit\n            )  # will set page.changed if the content of the page has changed\n        if not param.offline and page.changed:\n            if index is None:\n                print(f\"Entity stored at '{page.get_url()}'.\")\n            else:\n                print(\n                    f\"({index + 1}/{max_index}) Entity stored at \"\n                    f\"'{page.get_url()}'.\"\n                )\n        created_pages[page.title] = page\n\n    sorted_entities = OSW.sort_list_of_entities_by_class(param.entities)\n    print(\n        \"Entities to be uploaded have been sorted according to their type.\\n\"\n        \"If you would like to overwrite existing entities or properties, \"\n        \"pass a StoreEntityParam to store_entity() with \"\n        \"attribute 'overwrite' or 'overwrite_per_class' set to, e.g., \"\n        \"True.\"\n    )\n\n    class UploadObject(BaseModel):\n        entity: OswBaseModel\n        # Actually model.Entity but this causes the \"type\" error\n        namespace: Optional[str]\n        index: int\n        overwrite_class_param: OSW.OverwriteClassParam\n\n    upload_object_list: List[UploadObject] = []\n\n    upload_index = 0\n    for class_type, entities in sorted_entities.by_type.items():\n        # Try to get a class specific overwrite setting\n        class_param = param._overwrite_per_class[\"by type\"].get(class_type, None)\n        if class_param is None:\n            entity_model = entities[0].__class__\n            class_param = OSW.OverwriteClassParam(\n                model=entity_model,\n                overwrite=param.overwrite,\n            )\n            if param.debug:\n                print(\n                    f\"Now adding entities of class type '{class_type}' \"\n                    f\"({entity_model.__name__}) to upload list. No class specific\"\n                    f\" overwrite setting found. Using fallback option '\"\n                    f\"{param.overwrite}' for all entities of this class.\"\n                )\n        for entity in entities:\n            upload_object_list.append(\n                UploadObject(\n                    entity=entity,\n                    namespace=param.namespace,\n                    index=upload_index,\n                    overwrite_class_param=class_param,\n                )\n            )\n            upload_index += 1\n\n    def handle_upload_object_(upload_object: UploadObject) -&gt; None:\n        store_entity_(\n            upload_object.entity,\n            upload_object.namespace,\n            upload_object.index,\n            upload_object.overwrite_class_param,\n        )\n\n    if param.parallel:\n        _ = parallelize(\n            handle_upload_object_, upload_object_list, flush_at_end=param.debug\n        )\n    else:\n        _ = [\n            handle_upload_object_(upload_object)\n            for upload_object in upload_object_list\n        ]\n    return OSW.StoreEntityResult(change_id=param.change_id, pages=created_pages)\n</code></pre>"},{"location":"osw/#osw.core.OSW.unregister_schema","title":"<code>unregister_schema(schema_unregistration)</code>","text":"<p>deletes the corresponding category page</p> <p>Parameters:</p> Name Type Description Default <code>schema_unregistration</code> <code>SchemaUnregistration</code> <p>see SchemaUnregistration</p> required Source code in <code>src/osw/core.py</code> <pre><code>def unregister_schema(self, schema_unregistration: SchemaUnregistration):\n    \"\"\"deletes the corresponding category page\n\n    Parameters\n    ----------\n    schema_unregistration\n        see SchemaUnregistration\n    \"\"\"\n    uuid = \"\"\n    if schema_unregistration.model_uuid:\n        uuid = schema_unregistration.model_uuid\n    elif (\n        not uuid\n        and schema_unregistration.model_cls\n        and issubclass(schema_unregistration.model_cls, BaseModel)\n    ):\n        uuid = schema_unregistration.model_cls.__uuid__\n    else:\n        print(\"Error: Neither model nor model id provided\")\n\n    entity_title = \"Category:\" + OSW.get_osw_id(uuid)\n    page = self.site.get_page(WtSite.GetPageParam(titles=[entity_title])).pages[0]\n    page.delete(schema_unregistration.comment)\n</code></pre>"},{"location":"readme/","title":"Readme","text":"<p><code>{include} ../README.md :relative-docs: docs/ :relative-images:</code></p>"},{"location":"tools/","title":"Tools","text":"<p>Collection of helper functions</p>"},{"location":"tools/#osw.wiki_tools.SearchParam","title":"<code>SearchParam</code>","text":"<p>               Bases: <code>OswBaseModel</code></p> <p>Search parameters for semantic and prefix search</p> Source code in <code>src/osw/wiki_tools.py</code> <pre><code>class SearchParam(OswBaseModel):\n    \"\"\"Search parameters for semantic and prefix search\"\"\"\n\n    query: Union[str, List[str]]\n    parallel: Optional[bool] = None  # is set to true if query is a list longer than 5\n    debug: Optional[bool] = True\n    limit: Optional[int] = 1000\n\n    def __init__(self, **data):\n        super().__init__(**data)\n        if not isinstance(self.query, list):\n            self.query = [self.query]\n        if len(self.query) &gt; 5 and self.parallel is None:\n            self.parallel = True\n        if self.parallel is None:\n            self.parallel = False\n</code></pre>"},{"location":"tools/#osw.wiki_tools.copy_list_of_wiki_pages","title":"<code>copy_list_of_wiki_pages(title_list, site0, site1, overwrite, callback=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>title_list</code> <code>list</code> required <code>site0</code> <code>Site</code> <p>Source site object from mwclient lib</p> required <code>site1</code> <code>Site</code> <p>Target site object from mwclient lib</p> required <code>overwrite</code> <code>bool</code> <p>Whether to overwrite existing pages at target site</p> required <code>callback</code> <code>NoneType or function</code> <p>Function passed over, to perform operation on the titles of the source pages and to be passed as title of the target pages. See examples below. Example functions:     capitalize = lambda x: x.capitalize()     def change_namespace(title, namespace):         if \":\" in namespace:             namespace = namespace.split(\":\")[0]         if \":\" in title:             splits = title.split(\":\")             old_name = splits[1].capitalize()             new_title = namespace + \":\" + old_name         else:             new_title = namespace + \":\" + title.capitalize()         return new_title Examples of passing a function as parameter:     callback = capitalize     callback = lambda x: x.lower()</p> <code>None</code> <p>Returns:</p> Name Type Description <code>results_dict</code> <code>dict</code> <p>Dictionary, containing the results of the copying operations</p> Source code in <code>src/osw/wiki_tools.py</code> <pre><code>def copy_list_of_wiki_pages(title_list, site0, site1, overwrite, callback=None):\n    \"\"\"\n\n    Parameters\n    ----------\n    title_list : list\n    site0 : mwclient.client.Site\n        Source site object from mwclient lib\n    site1 : mwclient.client.Site\n        Target site object from mwclient lib\n    overwrite : bool\n        Whether to overwrite existing pages at target site\n    callback : NoneType or function\n        Function passed over, to perform operation on the titles of the source pages and\n        to be passed as title of the\n        target pages. See examples below.\n        Example functions:\n            capitalize = lambda x: x.capitalize()\n            def change_namespace(title, namespace):\n                if \":\" in namespace:\n                    namespace = namespace.split(\":\")[0]\n                if \":\" in title:\n                    splits = title.split(\":\")\n                    old_name = splits[1].capitalize()\n                    new_title = namespace + \":\" + old_name\n                else:\n                    new_title = namespace + \":\" + title.capitalize()\n                return new_title\n        Examples of passing a function as parameter:\n            callback = capitalize\n            callback = lambda x: x.lower()\n\n    Returns\n    -------\n    results_dict : dict\n        Dictionary, containing the results of the copying operations\n    \"\"\"\n\n    success_list = list()\n    fail_list = list()\n    for title0 in title_list:\n        if callback is None:\n            title1 = title0\n        else:\n            title1 = callback(title0)\n        success = copy_wiki_page(title0, title1, site0, site1, overwrite)\n        if success:\n            success_list.append(title1)\n        else:\n            fail_list.append(title1)\n    results_dict = {\n        \"Successfully copied pages\": success_list,\n        \"Pages failed to copy\": fail_list,\n    }\n    return results_dict\n</code></pre>"},{"location":"tools/#osw.wiki_tools.copy_wiki_page","title":"<code>copy_wiki_page(title0, title1, site0, site1, overwrite=True)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>title0</code> <code>str</code> <p>Title of the source page</p> required <code>title1</code> <code>str</code> <p>Title of the target page</p> required <code>site0</code> <code>Site</code> <p>Source site object from mwclient lib</p> required <code>site1</code> <code>Site</code> <p>Target site object from mwclient lib</p> required <code>overwrite</code> <code>bool</code> <p>Whether to overwrite existing pages at target site</p> <code>True</code> <p>Returns:</p> Name Type Description <code>success</code> <code>bool</code> Source code in <code>src/osw/wiki_tools.py</code> <pre><code>def copy_wiki_page(title0, title1, site0, site1, overwrite=True):\n    \"\"\"\n\n    Parameters\n    ----------\n    title0 : str\n        Title of the source page\n    title1 : str\n        Title of the target page\n    site0 : mwclient.client.Site\n        Source site object from mwclient lib\n    site1 : mwclient.client.Site\n        Target site object from mwclient lib\n    overwrite : bool\n        Whether to overwrite existing pages at target site\n\n    Returns\n    -------\n    success: bool\n\n    \"\"\"\n    if title0.lower() == title1.lower() and site0 == site1:\n        # copy on it self = no action necessary\n        success = True\n    else:\n        page0 = site0.pages[title0]\n        content = page0.text()\n        if overwrite:\n            success = create_or_overwrite_wiki_page(title1, content, site1)\n        else:\n            search_result = search_wiki_page(title1, site1)\n            if (\n                search_result[\"Result\"] and search_result[\"Exact match\"]\n            ):  # page already exists\n                success = False\n            else:\n                # search_result[\"Result\"] == True/False\n                # search_result[\"Exact match\"] == False\n                success = create_or_overwrite_wiki_page(title1, content, site1)\n    return success\n</code></pre>"},{"location":"tools/#osw.wiki_tools.create_or_overwrite_wiki_page","title":"<code>create_or_overwrite_wiki_page(title, content, site)</code>","text":"<p>Creates a page with the passed title and content. If the page already exists, the prior content is replaced with the passed content.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title of the wiki page, e.g., User:Someone1234</p> required <code>content</code> <code>str</code> required <code>site</code> <code>Site</code> <p>Site object from mwclient lib</p> required <p>Returns:</p> Name Type Description <code>success</code> <code>bool</code> Source code in <code>src/osw/wiki_tools.py</code> <pre><code>def create_or_overwrite_wiki_page(title, content, site):\n    \"\"\"Creates a page with the passed title and content. If the page already exists,\n    the prior content is replaced with the passed content.\n\n    Parameters\n    ----------\n    title : str\n        Title of the wiki page, e.g., User:Someone1234\n    content : str\n    site : mwclient.client.Site\n        Site object from mwclient lib\n\n    Returns\n    -------\n    success : bool\n    \"\"\"\n    target_page = site.pages[title]\n    target_page.edit(content, \"[bot] create page\")\n    success = True\n    return success\n</code></pre>"},{"location":"tools/#osw.wiki_tools.create_or_update_wiki_page_with_template","title":"<code>create_or_update_wiki_page_with_template(title, content, site, overwrite_with_empty=False)</code>","text":"<p>Creates a wiki page with a template included in the content. If the page does already exist, the parameters within the template are update</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title of the wiki page, e.g., User:Someone1234</p> required <code>content</code> <code>str</code> required <code>site</code> <code>Site</code> <p>Site object from mwclient lib</p> required <code>overwrite_with_empty</code> <code>bool</code> <p>Decided whether a template parameter's value in an preexisting page is overwritten with an empty value</p> <code>False</code> <p>Returns:</p> Name Type Description <code>success</code> <code>bool</code> Source code in <code>src/osw/wiki_tools.py</code> <pre><code>def create_or_update_wiki_page_with_template(\n    title, content, site, overwrite_with_empty=False\n):\n    \"\"\"Creates a wiki page with a template included in the content. If the page does\n    already exist, the parameters within the template are update\n\n    Parameters\n    ----------\n    title : str\n        Title of the wiki page, e.g., User:Someone1234\n    content : str\n    site : mwclient.client.Site\n        Site object from mwclient lib\n    overwrite_with_empty : bool\n        Decided whether a template parameter's value in an preexisting page is\n        overwritten with an empty value\n\n    Returns\n    -------\n    success : bool\n    \"\"\"\n    search_result = search_wiki_page(title, site)\n    if search_result[\"Result\"]:\n        existing_page = site.pages[title]\n        existing_text = existing_page.text()\n        # update the page's content (template only)\n        updated_content = update_template_within_wikitext(\n            text=existing_text,\n            template_text=content,\n            overwrite_with_empty=overwrite_with_empty,\n        )\n        success = create_or_overwrite_wiki_page(title, updated_content, site)\n    else:\n        # just create the page\n        success = create_or_overwrite_wiki_page(title, content, site)\n    return success\n</code></pre>"},{"location":"tools/#osw.wiki_tools.create_site_object","title":"<code>create_site_object(domain, password_file='', credentials=None)</code>","text":"<pre><code>Parameters\n</code></pre> <pre><code>domain :\n    Domain of the OSW instance, as specifed in the yaml file\npassword_file :\n    path to file with &lt;username&gt;\n</code></pre> <p>     credentials :         Dictionary with the credentials (username, password) <pre><code>Returns\n</code></pre> <pre><code>site : mwclient.client.Site\n    Site object from mwclient lib\n</code></pre> Source code in <code>src/osw/wiki_tools.py</code> <pre><code>def create_site_object(\n    domain: str, password_file: Union[str, FilePath] = \"\", credentials: dict = None\n) -&gt; mwclient.client.Site:\n    \"\"\"\n    Parameters\n    ----------\n    domain :\n        Domain of the OSW instance, as specifed in the yaml file\n    password_file :\n        path to file with &lt;username&gt;\\n&lt;password&gt;\n    credentials :\n        Dictionary with the credentials (username, password)\n    Returns\n    -------\n    site : mwclient.client.Site\n        Site object from mwclient lib\n    \"\"\"\n    domain_dict = {\n        \"wiki-dev\": {\"Address\": \"wiki-dev.open-semantic-lab.org\"},\n        \"onterface\": {\"Address\": \"onterface.open-semantic-lab.org:\"},\n    }\n    if domain in domain_dict.keys():\n        domain = domain_dict[domain][\"Address\"]\n\n    site = mwclient.Site(domain, path=\"/w/\")\n    if credentials is None:\n        credentials = read_credentials_from_yaml(password_file, domain)\n    # else:\n    #     credentials = credentials\n    # Login with dictionary unpacking:\n    # site.login(**credentials)\n    # Explicit login:\n    site.login(username=credentials[\"username\"], password=credentials[\"password\"])\n    del credentials\n    return site\n</code></pre>"},{"location":"tools/#osw.wiki_tools.delete_wiki_page","title":"<code>delete_wiki_page(title, site, reason)</code>","text":"<p>Deletes the wiki page with the passed title, if it was found (exact match!), otherwise returns False</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title of the wiki page, e.g., User:Someone1234</p> required <code>site</code> <code>Site</code> <p>Site object from mwclient lib</p> required <code>reason</code> <code>str</code> required <p>Returns:</p> Name Type Description <code>success</code> <code>bool</code> Source code in <code>src/osw/wiki_tools.py</code> <pre><code>def delete_wiki_page(title, site, reason):\n    \"\"\"Deletes the wiki page with the passed title, if it was found (exact match!),\n    otherwise returns False\n\n    Parameters\n    ----------\n    title : str\n        Title of the wiki page, e.g., User:Someone1234\n    site : mwclient.client.Site\n        Site object from mwclient lib\n    reason : str\n\n    Returns\n    -------\n    success : bool\n    \"\"\"\n    try:\n        page = site.pages[title]\n        page.delete(reason=reason, watch=False, unwatch=True, oldimage=False)\n        success = True\n    except mwclient.errors.APIError:\n        success = False\n    return success\n</code></pre>"},{"location":"tools/#osw.wiki_tools.edit_wiki_page_with_content_merge","title":"<code>edit_wiki_page_with_content_merge(title, new_content, site, template_name)</code>","text":"<p>Edits an existing wiki page, while merging the passed new content with the content of the existing page</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title of the wiki page, e.g., User:Someone1234</p> required <code>new_content</code> <code>str</code> required <code>site</code> <code>Site</code> <p>Site object from mwclient lib</p> required <code>template_name</code> <code>str</code> required <p>Returns:</p> Name Type Description <code>success</code> <code>bool</code> Source code in <code>src/osw/wiki_tools.py</code> <pre><code>def edit_wiki_page_with_content_merge(title, new_content, site, template_name):\n    \"\"\"Edits an existing wiki page, while merging the passed new content with the\n    content of the existing page\n\n    Parameters\n    ----------\n    title : str\n        Title of the wiki page, e.g., User:Someone1234\n    new_content : str\n    site : mwclient.client.Site\n        Site object from mwclient lib\n    template_name : str\n\n    Returns\n    -------\n    success : bool\n    \"\"\"\n    search_result = search_wiki_page(title, site)\n    if search_result[\"Result\"]:\n        source_page = site.pages[title]\n        source_page_content = source_page.text()\n        # todo: test function\n        new_content = merge_wiki_page_text(\n            new_content, source_page_content, template_name=template_name\n        )\n        target_page = site.pages[title]\n        target_page.edit(new_content, \"[bot] update of page content\")\n        success = True\n    else:\n        success = False\n    return success\n</code></pre>"},{"location":"tools/#osw.wiki_tools.get_file_info_and_usage","title":"<code>get_file_info_and_usage(site, title)</code>","text":"<p>(For 'File' pages only) Get information about the file and its usage</p> <p>Parameters:</p> Name Type Description Default <code>site</code> <code>Site</code> <p>Site object from mwclient lib.</p> required <code>title</code> <code>Union[str, List[str], SearchParam]</code> <p>Title(s) of the wiki page(s) or instance of SearchParam.</p> required <p>Returns:</p> Name Type Description <code>result</code> <code>List[Dict[str, Union[Dict[str, str], List[str]]]]</code> <p>Dictionary with page titles as keys and nested dictionary with keys 'info' and 'usage'.</p> Notes <p>Query to reproduce:     action=query     format=json     prop=imageinfo|fileusage     titles=File%3AOSW857d85031d85425aa94db8b4720e84b7.png     &amp;iiprop=timestamp%7Cuser&amp;fulimit=5000\"</p> Resources <p>Use the sandbox to design and test the queries: https://demo.open-semantic-lab.org/wiki/Special:ApiSandbox</p> Source code in <code>src/osw/wiki_tools.py</code> <pre><code>def get_file_info_and_usage(\n    site: mwclient.client.Site, title: Union[str, List[str], SearchParam]\n) -&gt; List[Dict[str, Union[Dict[str, str], List[str]]]]:\n    \"\"\"(For 'File' pages only) Get information about the file and its usage\n\n    Parameters\n    ----------\n    site:\n        Site object from mwclient lib.\n    title:\n        Title(s) of the wiki page(s) or instance of SearchParam.\n\n    Returns\n    -------\n    result:\n        Dictionary with page titles as keys and nested dictionary with keys 'info' and\n        'usage'.\n\n    Notes\n    -----\n    Query to reproduce:\n        action=query\n        format=json\n        prop=imageinfo|fileusage\n        titles=File%3AOSW857d85031d85425aa94db8b4720e84b7.png\n        &amp;iiprop=timestamp%7Cuser&amp;fulimit=5000\"\n\n    Resources\n    ---------\n    Use the sandbox to design and test the queries:\n    https://demo.open-semantic-lab.org/wiki/Special:ApiSandbox\n    \"\"\"\n    if not isinstance(title, SearchParam):\n        query = SearchParam(query=title, debug=False)\n    else:  # SearchParam\n        query = title\n\n    def get_file_info_and_usage_(single_title):\n        api_request_result = site.api(\n            action=\"query\",\n            format=\"json\",\n            prop=\"imageinfo|fileusage\",\n            titles=single_title,\n            iiprop=\"timestamp|user\",\n            fulimit=query.limit,\n        )\n        using_pages = []\n        file_info = {\n            \"title\": single_title,\n            \"author\": \"File not found or no creation logged\",\n            \"timestamp\": \"File not found or no creation logged\",\n            \"editor\": [],\n            \"editing_timestamp\": [],\n        }\n\n        if len(api_request_result[\"query\"][\"pages\"]) == 0:\n            if query.debug:\n                print(f\"Page not found: '{single_title}'!\")\n        else:\n            image_info: List[Dict[str, str]] = []\n            file_usage: List[Dict[str, Union[str, int]]] = []\n            for _page_id, page_dict in api_request_result[\"query\"][\"pages\"].items():\n                if page_dict[\"title\"] == single_title:\n                    image_info = page_dict.get(\"imageinfo\", [])\n                    file_usage = page_dict.get(\"fileusage\", [])\n            if len(image_info) != 0:\n                file_info[\"author\"] = image_info[0][\"user\"]\n                file_info[\"timestamp\"] = image_info[0][\"timestamp\"]\n                for ii in image_info:\n                    file_info[\"editor\"].append(ii[\"user\"])\n                    file_info[\"editing_timestamp\"].append(ii[\"timestamp\"])\n            if file_usage is not None:\n                for fu_page_dict in file_usage:\n                    using_pages.append(fu_page_dict[\"title\"])\n            if query.debug:\n                # todo: find out why this message is printed (sometimes) when using the\n                #  redirect,  which messes up the Progressbar\n                #  printed messages do not appear in the MessageBuffer\n                print(f\"File info for '{single_title}' retrieved.\")\n        return {\"info\": file_info, \"usage\": using_pages}\n\n    if query.parallel:\n        api_request_results = parallelize(\n            func=get_file_info_and_usage_,\n            iterable=query.query,\n            flush_at_end=query.debug,\n        )\n    else:\n        api_request_results = [\n            get_file_info_and_usage_(single_title=st) for st in query.query\n        ]\n\n    return api_request_results\n</code></pre>"},{"location":"tools/#osw.wiki_tools.prefix_search","title":"<code>prefix_search(site, text)</code>","text":"<p>Standard query. Equivalent to the following mediawiki API call api.php?action=query&amp;list=prefixsearch&amp;pssearch=Star Wars.</p> <p>See https://www.mediawiki.org/wiki/API:Prefixsearch for details.</p> <p>Parameters:</p> Name Type Description Default <code>site</code> <code>Site</code> <p>Site object from mwclient lib</p> required <code>text</code> <code>Union[str, SearchParam]</code> <p>Query text or instance of SearchParam</p> required <p>Returns:</p> Name Type Description <code>page_list</code> <code>List[str]</code> <p>List of page titles</p> Source code in <code>src/osw/wiki_tools.py</code> <pre><code>def prefix_search(\n    site: mwclient.client.Site, text: Union[str, SearchParam]\n) -&gt; List[str]:\n    \"\"\"Standard query. Equivalent to the following mediawiki API call\n    api.php?action=query&amp;list=prefixsearch&amp;pssearch=Star Wars.\n\n    See https://www.mediawiki.org/wiki/API:Prefixsearch for details.\n\n    Parameters\n    ----------\n    site :\n        Site object from mwclient lib\n    text :\n        Query text or instance of SearchParam\n\n    Returns\n    -------\n    page_list :\n        List of page titles\n    \"\"\"\n    if not isinstance(text, SearchParam):\n        query = SearchParam(query=text)\n    else:\n        query = text\n\n    def prefix_search_(single_text):\n        page_list = list()\n        result = site.api(\n            \"query\",\n            list=\"prefixsearch\",\n            pssearch=single_text,\n            pslimit=query.limit,\n            format=\"json\",\n        )\n        if len(result[\"query\"][\"prefixsearch\"]) == 0:\n            if query.debug:\n                print(\"No results\")\n        else:\n            for page in result[\"query\"][\"prefixsearch\"]:\n                title = page[\"title\"]\n                if query.debug:\n                    print(title)\n                page_list.append(title)\n        return page_list\n\n    if query.parallel:\n        query_results = parallelize(\n            func=prefix_search_, iterable=query.query, flush_at_end=query.debug\n        )\n    else:\n        query_results = [prefix_search_(single_text=sq) for sq in query.query]\n\n    return [item for sublist in query_results for item in sublist]\n</code></pre>"},{"location":"tools/#osw.wiki_tools.read_credentials_from_yaml","title":"<code>read_credentials_from_yaml(password_file, domain=None)</code>","text":"<p>Reads credentials from a yaml file</p> <p>Parameters:</p> Name Type Description Default <code>password_file</code> <code>Union[str, FilePath]</code> <p>Path to the yaml file with the credentials.</p> required <code>domain</code> <code>str</code> <p>Domain of the OSW instance, as specifed in the yaml file.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>credentials</code> <code>dict</code> <p>Dictionary with the credentials, expected to contain keys 'username' and 'password'.</p> Source code in <code>src/osw/wiki_tools.py</code> <pre><code>def read_credentials_from_yaml(\n    password_file: Union[str, FilePath], domain: str = None\n) -&gt; dict:\n    \"\"\"Reads credentials from a yaml file\n\n    Parameters\n    ----------\n    password_file :\n        Path to the yaml file with the credentials.\n    domain:\n        Domain of the OSW instance, as specifed in the yaml file.\n\n    Returns\n    -------\n    credentials :\n        Dictionary with the credentials, expected to\n        contain keys 'username' and 'password'.\n    \"\"\"\n    if password_file != \"\":\n        with open(password_file, \"r\") as stream:\n            try:\n                accounts = yaml.safe_load(stream)\n                if domain is not None and domain in accounts.keys():\n                    domain = domain\n                elif len(accounts.keys()) &gt; 0:\n                    domain = list(accounts.keys())[0]\n                    if len(accounts.keys()) &gt; 0:\n                        domain = list(accounts.keys())[0]\n                user = accounts[domain][\"username\"]\n                password = accounts[domain][\"password\"]\n            except yaml.YAMLError as exc:\n                print(exc)\n    else:\n        user = input(\"Enter bot username (username@botname)\")\n        password = getpass.getpass(\"Enter bot password\")\n    return {\"username\": user, \"password\": password}\n</code></pre>"},{"location":"tools/#osw.wiki_tools.read_domains_from_credentials_file","title":"<code>read_domains_from_credentials_file(cred_filepath)</code>","text":"<p>Reads domains and credentials from a yaml file</p> <p>Parameters:</p> Name Type Description Default <code>cred_filepath</code> <code>Union[str, FilePath]</code> <p>Path to the yaml file with the credentials</p> required Source code in <code>src/osw/wiki_tools.py</code> <pre><code>def read_domains_from_credentials_file(\n    cred_filepath: Union[str, FilePath]\n) -&gt; Tuple[List[str], Dict[str, Dict[str, str]]]:\n    \"\"\"Reads domains and credentials from a yaml file\n\n    Parameters\n    ----------\n    cred_filepath\n        Path to the yaml file with the credentials\n\n    Returns\n    -------\n\n    \"\"\"\n    with open(cred_filepath, \"r\", encoding=\"utf-8\") as stream_:\n        try:\n            accounts_dict = yaml.safe_load(stream_)\n            domains_list = list(accounts_dict.keys())\n            if len(domains_list) == 0:\n                raise ValueError(\"No domain found in accounts.pwd.yaml!\")\n            return domains_list, accounts_dict\n        except yaml.YAMLError as exc_:\n            print(exc_)\n</code></pre>"},{"location":"tools/#osw.wiki_tools.search_redirection_sources","title":"<code>search_redirection_sources(site, target_title, debug=False)</code>","text":"<p>Returns a list of pages redirecting to the page with target_title per #REDIRECT [[target]] syntax</p> <p>Parameters:</p> Name Type Description Default <code>site</code> <code>Site</code> <p>Site object from mwclient lib</p> required <code>target_title</code> <code>str</code> <p>Title of the target wiki page</p> required <code>debug</code> <code>bool</code> <p>Whether to print debugging messages</p> <code>False</code> <p>Returns:</p> Name Type Description <code>page_list</code> <code>list of pages redirecting to the page with target_title</code> Source code in <code>src/osw/wiki_tools.py</code> <pre><code>def search_redirection_sources(\n    site: mwclient.client.Site, target_title: str, debug: bool = False\n):\n    \"\"\"Returns a list of pages redirecting to the page with target_title per #REDIRECT\n    [[target]] syntax\n\n    Parameters\n    ----------\n    site :\n        Site object from mwclient lib\n    target_title :\n        Title of the target wiki page\n    debug:\n        Whether to print debugging messages\n\n    Returns\n    -------\n    page_list : list of pages redirecting to the page with target_title\n    \"\"\"\n    page_list = []\n    result = site.api(\"query\", titles=target_title, prop=\"redirects\", format=\"json\")\n    if len(result[\"query\"][\"pages\"]) == 0:\n        if debug:\n            print(\"No results\")\n    else:\n        for page in result[\"query\"][\"pages\"]:\n            if \"redirects\" not in result[\"query\"][\"pages\"][page]:\n                if debug:\n                    print(\"No results\")\n            else:\n                for redirecting_source in result[\"query\"][\"pages\"][page][\"redirects\"]:\n                    title = redirecting_source[\"title\"]\n                    page_list.append(title)\n    return page_list\n</code></pre>"},{"location":"tools/#osw.wiki_tools.search_wiki_page","title":"<code>search_wiki_page(title, site)</code>","text":"<p>Page search wrapper that adds exact match functionality with ignore-case on top of the  prefix_search()'s functionality.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title of the wiki page, e.g., User:Someone1234</p> required <code>site</code> <code>Site</code> <p>Site object from mwclient lib</p> required <p>Returns:</p> Name Type Description <code>result_dict</code> <code>dict</code> Source code in <code>src/osw/wiki_tools.py</code> <pre><code>def search_wiki_page(title: str, site: mwclient.client.Site):\n    \"\"\"Page search wrapper that adds exact match functionality with ignore-case on\n    top of the  prefix_search()'s functionality.\n\n    Parameters\n    ----------\n    title :\n        Title of the wiki page, e.g., User:Someone1234\n    site :\n        Site object from mwclient lib\n\n    Returns\n    -------\n    result_dict : dict\n    \"\"\"\n    result = site.api(\n        \"query\", list=\"prefixsearch\", pssearch=title, pslimit=1000, format=\"json\"\n    )\n    if len(result[\"query\"][\"prefixsearch\"]) == 0:\n        return {\"Result\": False, \"List\": list()}\n    else:\n        exact_match = False\n        page_title_list = list()\n        for page in result[\"query\"][\"prefixsearch\"]:\n            page_title = page[\"title\"]\n            page_title_list.append(page_title)\n            if page_title.lower() == title.lower():\n                exact_match = True\n        result_dict = {\n            \"Result\": True,\n            \"List\": page_title_list,\n            \"Exact match\": exact_match,\n        }\n        return result_dict\n</code></pre>"},{"location":"tools/#osw.wiki_tools.semantic_search","title":"<code>semantic_search(site, query)</code>","text":"<p>Semantic query</p> <p>Parameters:</p> Name Type Description Default <code>site</code> <code>Site</code> <p>Site object from mwclient lib</p> required <code>query</code> <code>Union[str, List[str], SearchParam]</code> <p>(List of) query text(s) or instance of SearchParam</p> required <p>Returns:</p> Name Type Description <code>page_list</code> <code>List[str]</code> <p>List of page titles</p> Source code in <code>src/osw/wiki_tools.py</code> <pre><code>def semantic_search(\n    site: mwclient.client.Site, query: Union[str, List[str], SearchParam]\n) -&gt; List[str]:\n    \"\"\"Semantic query\n\n    Parameters\n    ----------\n    site :\n        Site object from mwclient lib\n    query :\n        (List of) query text(s) or instance of SearchParam\n\n    Returns\n    -------\n    page_list:\n        List of page titles\n    \"\"\"\n    if not isinstance(query, SearchParam):\n        query = SearchParam(query=query)\n\n    def semantic_search_(single_query):\n        page_list = list()\n        single_query += f\"|limit={query.limit}\"\n        result = site.api(\"ask\", query=single_query, format=\"json\")\n        if len(result[\"query\"][\"results\"]) == 0:\n            if query.debug:\n                print(\"Query '{}' returned no results\".format(single_query))\n        else:\n            if query.debug:\n                print(\n                    \"Query '{}' returned {} results\".format(\n                        single_query, len(result[\"query\"][\"results\"])\n                    )\n                )\n            for page in result[\"query\"][\"results\"].values():\n                # why do we do the following?\n                if \"printouts\" in page:\n                    title = page[\"fulltext\"]\n                    if \"#\" not in title and query.debug:\n                        print(title)\n                        # original position of \"page_list.append(title)\" line\n                    page_list.append(title)\n        return page_list\n\n    if query.parallel:\n        query_results = parallelize(\n            func=semantic_search_, iterable=query.query, flush_at_end=query.debug\n        )\n    else:\n        query_results = [semantic_search_(single_query=sq) for sq in query.query]\n\n    return [item for sublist in query_results for item in sublist]\n</code></pre>"}]}